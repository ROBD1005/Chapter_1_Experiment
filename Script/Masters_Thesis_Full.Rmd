---
title: "Masters Thesis Full"
author: "R.J. Dellinger"
date: "`r Sys.Date()`"
output: html_document
---

# Loading Libraries 

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Data manipulation and general utilities
library(broom)
library(car)
library(dplyr)
library(gt)
library(gtsummary)
library(gtExtras)
library(here)
library(lubridate)
library(magick)
library(measurements)
library(png)
library(readr)
library(tidyr)       
library(stringr)

# Plotting and visualization
library(cowplot)
library(ggfx)
library(ggimage)
library(gginnards)
library(ggmap)
library(ggpmisc)
library(ggpubr)
library(ggsci)
library(ggmapinset)
library(ggplot2)
library(ggrepel)
library(ggspatial)
library(ggstatsplot)
library(gridExtra)
library(ggforce)
library(hrbrthemes)
library(latex2exp)
library(patchwork)
library(purrr) 

# Geospatial data handling
library(rnaturalearth)
library(rnaturalearthdata)
#install_github("ropensci/rnaturalearthhires")
library(rnaturalearthhires)
library(raster)
library(sf)
library(lwgeom)

# Statistical analysis and modeling
library(zoo)
library(performance)
library(tools)
library(rTPC)
library(boot)
library(minpack.lm)
library(nlstools)
library(nls.multstart)
library(respR)
library(respirometry)
#install_github('colin-olito/LoLinR')
library(LoLinR)
library(NISTunits)
library(rstatix)

# Define Functions & Formatting 
format_p_values <- function(data) {
  data %>%
    mutate(
      p.value = case_when(
        p.value < 0.001 ~ "<0.001 ***",
        p.value < 0.01  ~ "<0.01 **",
        p.value < 0.05  ~ "<0.05 *",
        is.na(p.value)  ~ "",
        TRUE            ~ sprintf("%.2f", p.value)  # Use sprintf for precise formatting
      )
    )
}

# Define a custom theme for ggplot
common_theme <- theme_minimal(base_family="serif") +
  theme(
    # Set the background to white
    plot.background = element_rect(fill = "white", colour = "white"),
    # Set font family and color for text
    text = element_text(family = "serif", color = "black"),
    # Remove legend
    legend.position = 'none',
    # Adjust strip text for facetted plots
    strip.text = element_text(hjust = 0.5, size = 9, family = "serif"), 
    strip.text.x = element_text(vjust = 0.5, size = 11, family = "serif"), 
    strip.text.y = element_text(vjust = 0.5, size = 11, family = "serif"), 
    # Adjust axis titles
    axis.title.x = element_text(margin = margin(t = 7.5), size = 12, hjust = 0.5, family = "serif"),
    axis.title.y = element_text(margin = margin(r = 7.5), size = 12, vjust = 0.5, family = "serif"),
    # Adjust axis text
    axis.text = element_text(size = 9, family = "serif"),
    # Adjust plot title
    plot.title = element_text(hjust = 0.5, size = 14, family = "serif"),
    # Adjust plot margins
    plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit="cm"),
    # Increase line thickness
    panel.border = element_rect(color = NA, fill = NA, size = 0.5),
    # Set panel grid lines
    panel.grid.major = element_line(color = "gray75", linewidth = 0.15),
    panel.grid.minor = element_blank()
  )

gt_theme <- function(data,...) {
  data %>%
  opt_table_font(
    font = "serif") %>%
    fmt_number(
    columns = everything(),
    decimals = 2) %>% 
  tab_style(
      style = list(cell_text(align = "center", font = "serif",
                             size = 12, color = "black", weight=250),
      cell_borders(
        side = "bottom", color = "black", weight = px(1))),
      locations = cells_body(
        columns = everything(), rows = nrow(data$`_data`))
    ) %>%
  tab_style(
    style=list(cell_text(align = "center",
                      font = "serif", weight="bolder",
                      size = 14, color = "black"), 
        cell_fill(color = "grey50", alpha = 0.01),
        cell_borders(
        sides = "top", 
        color = "black",
        weight = px(2)
        )),
    locations = cells_title(groups = "title")
  ) %>%
  tab_style(
    style=list(cell_text(align = "center",
                      font = "serif",
                      size = 12, color = "black"), 
        cell_fill(color = "grey50", alpha = 0.01),
        cell_borders(
        sides = "bottom", 
        color = "black",
        weight = px(2)
        )),
    locations = cells_title(groups = "subtitle")
  ) %>%
    tab_style(
    style = cell_text(align = "center", font = "serif", weight="bold", size = 12, color = "black"),
    locations = cells_column_labels(columns = everything()) 
  ) %>%
  tab_style(
    style = cell_text(align = "center", font = "serif", size = 12, color = "black"),
    locations = cells_body()
  ) %>% 
  tab_options(
    table.width = pct(50),
    table.border.top.width = px(1),
    table.border.top.color = "black",
    table.border.bottom.color = "black",
    table.border.bottom.width = px(2),
    table_body.border.bottom.width = px(2),
    table_body.border.bottom.color = "black",
    table_body.border.top.width = px(2),
    table_body.border.top.color = "black",
    table_body.hlines.width = px(0.5),
    table_body.hlines.color = "grey90",
    column_labels.background.color = "white",
    column_labels.border.top.width = px(2),
    column_labels.border.top.color = "black",
    column_labels.border.bottom.width = px(2),
    column_labels.border.bottom.color = "black",
    row_group.border.top.width = px(1.25),
    row_group.border.top.color = "black",
    row_group.border.bottom.width = px(1.25),
    row_group.border.bottom.color = "black",
    source_notes.font.size = 12,
    table.font.size = 12,
    heading.title.font.size = 14,
    heading.subtitle.font.size = 12,
    heading.align = "center",
    heading.padding = px(5),
    row_group.padding = px(4),
    data_row.padding = px(3),
    ...
  ) 
}
```

# Thermal Performance Schematic (using generated data with quadratic equations to illustrate hypothesis)

```{r, Thermal Performance Schematic, warning=FALSE, message=FALSE}
# Extend the temperature values from 0 to 32
temperatures <- seq(0, 32, by = 1)

peak_rate_low=150
metabolic_rate_low <- ifelse(temperatures <= 16, 
                             (peak_rate_low / 80) * (4 * temperatures - (temperatures^2 / 18)),  
                             ifelse(temperatures <= 19,  # Starting the decline earlier and ending it sooner at 19°C
                                    peak_rate_low - 5 * (peak_rate_low / 60) * (temperatures - 16)^2.5,  # Steeper and quicker decline
                                    24))  # Set to 24 after 19°C

# Convert to tibble for low pH
metabolic_rate_low <- tibble(temp = temperatures, rate = metabolic_rate_low, curve_id = "low")

peak_rate_high=80
# High pH curve with adjustments at the ends
metabolic_rate_ambient <- ifelse(temperatures <= 22, 
                                 (peak_rate_high / 100) * (5 * temperatures - (temperatures^2 / 22)), 
                                 ifelse(temperatures <= 27, 
                                        peak_rate_high - ((temperatures - 22) / (27 - 22)) * (peak_rate_high - 40), 
                                        10))  # Set to 0 after 27°C

# Convert to tibble for high pH
metabolic_rate_ambient <- tibble(temp = temperatures, rate = metabolic_rate_ambient, curve_id = "high")

# Combine both data frames
df_tpc <- bind_rows(metabolic_rate_ambient, metabolic_rate_low)

high_data <- subset(df_tpc, curve_id == "high")

# get start vals
high_start_vals <- get_start_vals(high_data$temp, high_data$rate, model_name = 'sharpeschoolhigh_1981')
# get limits
high_low_lims <- get_lower_lims(high_data$temp, high_data$rate, model_name = 'sharpeschoolhigh_1981')
high_upper_lims <- get_upper_lims(high_data$temp, high_data$rate, model_name = 'sharpeschoolhigh_1981')

# fit model
high_fit <- nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                                                     data = high_data,
                                                     iter = 1,
                                                     start_lower = high_start_vals,
                                                     start_upper = high_start_vals,
                                                     lower = high_low_lims,
                                                     upper = high_upper_lims,
                                                     supp_errors = 'Y')
# predict new data
high_new_data <- data.frame(temp = seq(min(high_data$temp), max(high_data$temp), 0.5))
high_preds <- augment(high_fit, newdata = high_new_data)

low_data <- subset(df_tpc, curve_id == "low")
# get start vals
low_start_vals <- get_start_vals(low_data$temp, low_data$rate, model_name = 'sharpeschoolhigh_1981')
# get limits
low_low_lims <- get_lower_lims(low_data$temp, low_data$rate, model_name = 'sharpeschoolhigh_1981')
low_upper_lims <- get_upper_lims(low_data$temp, low_data$rate, model_name = 'sharpeschoolhigh_1981')

# fit model
low_fit <- nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                                                     data = low_data,
                                                     iter = 1,
                                                     start_lower = low_start_vals,
                                                     start_upper = low_start_vals,
                                                     lower = low_low_lims,
                                                     upper = low_upper_lims,
                                                     supp_errors = 'Y')

# predict new data
low_new_data <- data.frame(temp = seq(min(low_data$temp), max(low_data$temp), 0.5))
low_preds <- augment(low_fit, newdata = low_new_data)

# calculate topt
low_topt <- get_topt(low_fit)
high_topt <- get_topt(high_fit)
# Calculate the highest point of each curve
low_rmax <- get_rmax(low_fit)
high_rmax <- get_rmax(high_fit)
# calculate ct max and min 
low_ctmax <- get_ctmax(low_fit)
high_ctmax <- get_ctmax(high_fit)
low_ctmin <- get_ctmin(low_fit)
high_ctmin <- get_ctmin(high_fit)
# calculate thermal breadth range
low_tbr <- get_breadth(low_fit)
high_tbr <- get_breadth(high_fit)

# plotting tbr calculation 
# Calculate 80% of the peak rate
rmax_80 <- 0.8 * high_rmax
# Filter the temperatures at or above 80% of the maximum rate
temp_at_80pct <- high_preds$temp[high_preds$.fitted >= rmax_80]
# Determine the minimum and maximum temperatures of this range
tbr_temp_range <- range(temp_at_80pct)
middle_point_high <- mean(tbr_temp_range) # for plotting label 

# thermal breadt hfor low ph
low_rmax_80 <- 0.8 * low_rmax
temp_at_80pct_low <- low_preds$temp[low_preds$.fitted >= low_rmax_80]
tbr_temp_range_low <- range(temp_at_80pct_low)

# Create a tibble with a single fake point for temp color bar
temp_data <- tibble(x = 32, y = 1, diff = 0)

# Define the coordinates for the key square
square_data <- data.frame(
  xmin = 26.5,
  xmax = 28,
  ymin = 97,
  ymax = 100
)


low_preds <- low_preds %>%
  filter(temp <= 24)

high_preds <- high_preds %>%
  filter(.fitted > 5)
TPC_schematic <- # Extend the temperature values from 0 to 32
temperatures <- seq(0, 32, by = 1)

peak_rate_low=150
metabolic_rate_low <- ifelse(temperatures <= 16, 
                             (peak_rate_low / 80) * (4 * temperatures - (temperatures^2 / 18)),  
                             ifelse(temperatures <= 19,  # Starting the decline earlier and ending it sooner at 19°C
                                    peak_rate_low - 5 * (peak_rate_low / 60) * (temperatures - 16)^2.5,  # Steeper and quicker decline
                                    24))  # Set to 24 after 19°C

# Convert to tibble for low pH
metabolic_rate_low <- tibble(temp = temperatures, rate = metabolic_rate_low, curve_id = "low")

peak_rate_high=80
# High pH curve with adjustments at the ends
metabolic_rate_ambient <- ifelse(temperatures <= 22, 
                                 (peak_rate_high / 100) * (5 * temperatures - (temperatures^2 / 22)), 
                                 ifelse(temperatures <= 27, 
                                        peak_rate_high - ((temperatures - 22) / (27 - 22)) * (peak_rate_high - 40), 
                                        10))  # Set to 0 after 27°C

# Convert to tibble for high pH
metabolic_rate_ambient <- tibble(temp = temperatures, rate = metabolic_rate_ambient, curve_id = "high")

# Combine both data frames
df_tpc <- bind_rows(metabolic_rate_ambient, metabolic_rate_low)

high_data <- subset(df_tpc, curve_id == "high")

# get start vals
high_start_vals <- get_start_vals(high_data$temp, high_data$rate, model_name = 'sharpeschoolhigh_1981')
# get limits
high_low_lims <- get_lower_lims(high_data$temp, high_data$rate, model_name = 'sharpeschoolhigh_1981')
high_upper_lims <- get_upper_lims(high_data$temp, high_data$rate, model_name = 'sharpeschoolhigh_1981')

# fit model
high_fit <- nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                                                     data = high_data,
                                                     iter = 1,
                                                     start_lower = high_start_vals,
                                                     start_upper = high_start_vals,
                                                     lower = high_low_lims,
                                                     upper = high_upper_lims,
                                                     supp_errors = 'Y')
# predict new data
high_new_data <- data.frame(temp = seq(min(high_data$temp), max(high_data$temp), 0.5))
high_preds <- augment(high_fit, newdata = high_new_data)

low_data <- subset(df_tpc, curve_id == "low")
# get start vals
low_start_vals <- get_start_vals(low_data$temp, low_data$rate, model_name = 'sharpeschoolhigh_1981')
# get limits
low_low_lims <- get_lower_lims(low_data$temp, low_data$rate, model_name = 'sharpeschoolhigh_1981')
low_upper_lims <- get_upper_lims(low_data$temp, low_data$rate, model_name = 'sharpeschoolhigh_1981')

# fit model
low_fit <- nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                                                     data = low_data,
                                                     iter = 1,
                                                     start_lower = low_start_vals,
                                                     start_upper = low_start_vals,
                                                     lower = low_low_lims,
                                                     upper = low_upper_lims,
                                                     supp_errors = 'Y')

# predict new data
low_new_data <- data.frame(temp = seq(min(low_data$temp), max(low_data$temp), 0.5))
low_preds <- augment(low_fit, newdata = low_new_data)

# calculate topt
low_topt <- get_topt(low_fit)
high_topt <- get_topt(high_fit)
# Calculate the highest point of each curve
low_rmax <- get_rmax(low_fit)
high_rmax <- get_rmax(high_fit)
# calculate ct max and min 
low_ctmax <- get_ctmax(low_fit)
high_ctmax <- get_ctmax(high_fit)
low_ctmin <- get_ctmin(low_fit)
high_ctmin <- get_ctmin(high_fit)
# calculate thermal breadth range
low_tbr <- get_breadth(low_fit)
high_tbr <- get_breadth(high_fit)

# plotting tbr calculation 
# Calculate 80% of the peak rate
rmax_80 <- 0.8 * high_rmax
# Filter the temperatures at or above 80% of the maximum rate
temp_at_80pct <- high_preds$temp[high_preds$.fitted >= rmax_80]
# Determine the minimum and maximum temperatures of this range
tbr_temp_range <- range(temp_at_80pct)
middle_point_high <- mean(tbr_temp_range) # for plotting label 

# thermal breadt hfor low ph
low_rmax_80 <- 0.8 * low_rmax
temp_at_80pct_low <- low_preds$temp[low_preds$.fitted >= low_rmax_80]
tbr_temp_range_low <- range(temp_at_80pct_low)

# Create a tibble with a single fake point for temp color bar
temp_data <- tibble(x = 32, y = 1, diff = 0)

# Define the coordinates for the key square
square_data <- data.frame(
  xmin = 26.5,
  xmax = 28,
  ymin = 97,
  ymax = 100
)

heat_colors <- c(
    "#ffffcc", 
    "#ffeda0",
    "#fed976",  
    "#ffd480",
    "#feb24c",  
    "#ff9a17",
    "#fd8d3c",  
    "#fc4e2a",
    "#fc4e2a",  
    "#e31a1c", 
    "red3"
)

low_preds <- low_preds %>%
  filter(temp <= 24)

high_preds <- high_preds %>%
  filter(.fitted > 5)

TPC_schematic <- ggplot() +
  geom_point(data = temp_data, aes(x = x, y = y, fill = diff), color = "black", size=1, alpha=.01) +
  #plotting ct max and min for the ambient curve above the low curve 
  geom_segment(aes(x = high_ctmax-3, y = 5, xend = high_ctmax-3, yend = high_rmax[1]* 0.175), linetype = "dotted", col = 'black') +
  geom_segment(aes(x = high_ctmax-3, y = high_rmax[1]* 0.35, xend = high_ctmax-3, yend = high_rmax[1]* 0.225), 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")), color = "black", size = 0.5) + 
  geom_text(aes(x =  high_ctmax-3, y = high_rmax[1]*0.4), label = TeX("$CT_{max}$"), size=7, color = "black", family = "serif") +  # Label for CTmax 
  geom_segment(aes(x=1, y=5, xend = 1, yend = high_rmax[1]*0.175), linetype = "dotted", col = 'black') +
  geom_segment(aes(x = 1, y = high_rmax[1]*0.35, xend = 1, yend = high_rmax[1]*0.225), 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")), color = "black", size = 0.5) +
  geom_text(aes(x = 1, y = high_rmax[1]*0.4), label = TeX("$CT_{min}$"), size=7, color = "black", family = "serif") +  # Label for CTmin
  #plotting the ambient curve 
  geom_line(data = high_preds, aes(temp, .fitted, color = "high"), size = 1, col = 'black') + # High metabolic rate curve
  geom_segment(aes(x = high_topt[1], y = 5, xend = high_topt[1], yend = high_rmax[1]), linetype = "dashed", col = 'black', size=0.5)+  # Thermal Opt Line
  geom_segment(aes(x=0, y=high_rmax[1], xend = high_topt[1], yend = high_rmax[1]), linetype = "dashed", col = 'black', size=0.5) +
  geom_text(aes(x = 1, y = high_rmax[1]), label = TeX("$R_{max}$"), size=7, vjust = -0.5, color = "black", family = "serif") +
  geom_text(aes(x = high_topt[1], y = high_rmax[1]), label = TeX("$T_{opt}$"), size=7, vjust = -0.5, color = "black", family = "serif") +  # Label for Thermal Optimum
  geom_segment(aes(x = tbr_temp_range[1]+0.25, y = high_rmax[1]*0.8, xend = tbr_temp_range[2]-0.15, yend = high_rmax[1]*0.8), 
               linetype = "dotted", color = "black", size = 0.5, arrow = arrow(type = "closed", length = unit(0.15, "inches"), ends = "both"))+
  geom_text(aes(x = middle_point_high[1], y = high_rmax[1]* 0.8), label = TeX("$T_{br}$"), size=7, vjust = 1.3, hjust=0.8, color = "black", family = "serif") +
  geom_segment(aes(x = high_topt-6, xend = high_topt-3, y = high_rmax[1]*0.76, yend = high_rmax[1]*0.95), 
                 arrow = arrow(length = unit(0.3, "cm")), color = "black") +  # Representing Ea
  geom_text(aes(x = high_topt-5, y = high_rmax[1] * 0.925), label = TeX("$E_{a}$"), size=7, color = "black", family = "serif") +
  geom_segment(aes(x = high_topt+3, xend = high_topt+5, y = high_rmax[1]*0.88, yend = high_rmax[1]*0.6), 
                 arrow = arrow(length = unit(0.3, "cm")), color = "black") +
  geom_text(aes(x = high_topt+4.5, y = high_rmax[1] * 0.825), label = TeX("$E_{h}$"), size=7, color = "black", family = "serif") +
geom_segment(aes(y= 5, yend=5, x=0, xend=36), linetype = "dashed", color = "black", linewidth=1) +  # Dotted line at y = 0
#geom_hline(yintercept = 5, linetype = "dashed", color = "black", linewidth=1) +  # Dotted line at y = 0
scale_fill_gradientn(colors = heat_colors, limits = c(0, 26), guide = guide_colorbar(title = "Temperature", title.position = "bottom", ticks.colour = NA))+
theme_minimal() +  # Start with a minimal theme
  labs(x=NULL, y = "Metabolic Rate") +  # Add y-axis label
  theme(plot.background = element_blank(),  # Remove background elements
        panel.background = element_blank(),  # Remove panel background elements
        axis.line = element_line(arrow = arrow(type = "closed", length = unit(0.2, "inches")), size = 1, color="black"),
        panel.border = element_blank(),
        axis.title.x = element_blank(),  # Remove x-axis title
        axis.title.y = element_text(size = rel(1.5), family="serif"),
        axis.text = element_blank(),
        axis.text.x = element_blank(),  # Optional: Remove x-axis text if desired
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        text=element_text(size=12, family="serif"),
        legend.position = "bottom",
        legend.direction = "horizontal",
        legend.key = element_blank(),
        legend.key.width = unit(0.17, "npc"),
        legend.key.height = unit(5, "mm"),
        legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
        legend.box.margin = margin(t = -5, r = 0, b = 0, l = 0),
        legend.title = element_text(hjust = 0.5, size = rel(1.4), family="serif"),  # Apply serif font to legend title
        legend.text = element_blank(),  # Apply serif font to legend text
        plot.margin = margin(0.3, 0.3, 0.3, 0.3, "cm"),
        plot.title = element_text(family="serif")) + # Apply serif font to the plot title if you have one
  xlim(0, 36) +
  ylim(0, 80) 

print(TPC_schematic)

TPC_schematic_hypothesis <- ggplot() +
  geom_point(data = temp_data, aes(x = x, y = y, fill = diff), color = "black", size=1, alpha=.01) +
  #plotting the low curve first 
  geom_line(data = low_preds, aes(temp, .fitted, color = "low"), size = 1, col = 'cyan3') +     # Low metabolic rate curve
  geom_segment(aes(x = low_topt[1], y = 5, xend = low_topt[1], yend = low_rmax[1]), linetype = "dashed", col = 'cyan3', size=0.5) + 
  geom_segment(aes(x=0, y=low_rmax[1], xend = low_topt[1], yend = low_rmax[1]), linetype = "dashed", col = 'cyan3', size=0.5) +
  geom_segment(aes(x=tbr_temp_range_low[1]+0.25, y = low_rmax[1]*0.8, xend = tbr_temp_range_low[2], yend = low_rmax[1]*0.8), 
               linetype = "dotted", color = "cyan3", size = 0.5)+
  #plotting ct max and min for the ambient curve above the low curve 
  geom_segment(aes(x = high_ctmax-3, y = 5, xend = high_ctmax-3, yend = high_rmax[1]* 0.175), linetype = "dotted", col = 'black') +
  geom_segment(aes(x = high_ctmax-3, y = high_rmax[1]* 0.35, xend = high_ctmax-3, yend = high_rmax[1]* 0.225), 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")), color = "black", size = 0.5) + 
  geom_text(aes(x =  high_ctmax-3, y = high_rmax[1]*0.4), label = TeX("$CT_{max}$"), size=7, color = "black", family = "serif") +  # Label for CTmax 
  geom_segment(aes(x=1, y=5, xend = 1, yend = high_rmax[1]*0.175), linetype = "dotted", col = 'black') +
  geom_segment(aes(x = 1, y = high_rmax[1]*0.35, xend = 1, yend = high_rmax[1]*0.225), 
               arrow = arrow(type = "closed", length = unit(0.1, "inches")), color = "black", size = 0.5) +
  geom_text(aes(x = 1, y = high_rmax[1]*0.4), label = TeX("$CT_{min}$"), size=7, color = "black", family = "serif") +  # Label for CTmin
  #plotting the ambient curve 
  geom_line(data = high_preds, aes(temp, .fitted, color = "high"), size = 1, col = 'orange') + # High metabolic rate curve
  geom_segment(aes(x = high_topt[1], y = 5, xend = high_topt[1], yend = high_rmax[1]), linetype = "dashed", col = 'orange1', size=0.5)+  # Thermal Opt Line
  geom_segment(aes(x=0, y=high_rmax[1], xend = high_topt[1], yend = high_rmax[1]), linetype = "dashed", col = 'orange1', size=0.5) +
  geom_text(aes(x = 1, y = high_rmax[1]), label = TeX("$R_{max}$"), size=7, vjust = -0.5, color = "black", family = "serif") +
  geom_text(aes(x = high_topt[1], y = high_rmax[1]), label = TeX("$T_{opt}$"), size=7, vjust = -0.5, color = "black", family = "serif") +  # Label for Thermal Optimum
  geom_segment(aes(x = tbr_temp_range[1]+0.25, y = high_rmax[1]*0.8, xend = tbr_temp_range[2]-0.15, yend = high_rmax[1]*0.8), 
               linetype = "dotted", color = "black", size = 0.5, arrow = arrow(type = "closed", length = unit(0.15, "inches"), ends = "both"))+
  geom_text(aes(x = middle_point_high[1], y = high_rmax[1]* 0.8), label = TeX("$T_{br}$"), size=7, vjust = 1.3, hjust=0.8, color = "black", family = "serif") +
  geom_segment(aes(x = high_topt-6, xend = high_topt-3, y = high_rmax[1]*0.76, yend = high_rmax[1]*0.95), 
                 arrow = arrow(length = unit(0.3, "cm")), color = "black") +  # Representing Ea
  geom_text(aes(x = high_topt-5, y = high_rmax[1] * 0.925), label = TeX("$E_{a}$"), size=7, color = "black", family = "serif") +
  geom_segment(aes(x = high_topt+3, xend = high_topt+5, y = high_rmax[1]*0.88, yend = high_rmax[1]*0.6), 
                 arrow = arrow(length = unit(0.3, "cm")), color = "black") +
  geom_text(aes(x = high_topt+4.5, y = high_rmax[1] * 0.825), label = TeX("$E_{h}$"), size=7, color = "black", family = "serif") +
geom_segment(aes(y= 5, yend=5, x=0, xend=36), linetype = "dashed", color = "black", linewidth=1) +  # Dotted line at y = 0
#geom_hline(yintercept = 5, linetype = "dashed", color = "black", linewidth=1) +  # Dotted line at y = 0
scale_fill_gradientn(colors = heat_colors, limits = c(0, 26), guide = guide_colorbar(title = "Temperature", title.position = "bottom", ticks.colour = NA))+
scale_color_manual(values = c("orange", "cyan3"), 
                     labels = c("Ambient pH", "Decreased pH"), guide = FALSE) +
theme_minimal() +  # Start with a minimal theme
  labs(x=NULL, y = "Respiration Rate") +  # Add y-axis label
  theme(plot.background = element_blank(),  # Remove background elements
        panel.background = element_blank(),  # Remove panel background elements
        axis.line = element_line(arrow = arrow(type = "closed", length = unit(0.2, "inches")), size = 1, color="black"),
        panel.border = element_blank(),
        axis.title.x = element_blank(),  # Remove x-axis title
        axis.title.y = element_text(size = rel(1.5), family="serif"),
        axis.text = element_blank(),
        axis.text.x = element_blank(),  # Optional: Remove x-axis text if desired
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        text=element_text(size=12, family="serif"),
        legend.position = "bottom",
        legend.direction = "horizontal",
        legend.key = element_blank(),
        legend.key.width = unit(0.17, "npc"),
        legend.key.height = unit(5, "mm"),
        legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
        legend.box.margin = margin(t = -5, r = 0, b = 0, l = 0),
        legend.title = element_text(hjust = 0.5, size = rel(1.4), family="serif"),  # Apply serif font to legend title
        legend.text = element_blank(),  # Apply serif font to legend text
        plot.margin = margin(0.3, 0.3, 0.3, 0.3, "cm"),
        plot.title = element_text(family="serif")) + # Apply serif font to the plot title if you have one
  xlim(0, 36) +  # Set x-axis limits
    geom_rect(data = square_data, aes(xmin = xmin, xmax = xmax, ymin = ymin-2.5, ymax = ymax-2.5), 
            fill = "orange", color = "orange") +
  geom_rect(data = square_data, aes(xmin = xmin, xmax = xmax, ymin = ymin-10.5, ymax = ymax-10.5), 
            fill = "cyan3", color = "cyan3") + 
  #geom_rect(data = square_data, aes(xmin = xmin-1, xmax = xmax+7.5, ymin = ymin-14, ymax = ymax+1),
          #  fill = NA, color = "black", size = 0.5) + # This will draw the border around the square
  annotate("text", x = square_data$xmax+3.1, y = square_data$ymax-3.75, family = "serif", label = "Ambient pH", size=5, color = "black") +
  annotate("text", x = square_data$xmax+3.65, y = square_data$ymax-11.75, family = "serif", label = "Decreased pH", size=5, color = "black")

print(TPC_schematic_hypothesis)

ggsave(here::here("Figures", "TPC_schematic.png"), plot = TPC_schematic, width = 8, height = 6, dpi = 1300)
ggsave(here::here("Figures", "TPC_schematic_hypothesis.png"), plot = TPC_schematic_hypothesis, width = 8, height = 6, dpi = 1300)

```


```{r Clearing Environment, message=FALSE, include=FALSE} 
# Clear the environment
rm(list = ls())
```

# Mapping Study Site

```{r, Creating Study Site Map, warning =FALSE, message=FALSE}

# Define study site coordinates and labels
center_lon <- -118.28599
center_lat <- 33.70679092
location <-  "(Point Fermin State Beach, CA)"

# Define regional area
regional_lonlim <- c(-126, -114)
regional_latlim <- c(28, 44)

# Expand the limits by on each side
studysite_lonlim <- c(floor(center_lon)-0.5, ceiling(center_lon)+0.5)
studysite_latlim <- c(floor(center_lat)-0.5, ceiling(center_lat)+0.5)

# Define bounding box coordinates for the west coast 
regional_bbox <- st_bbox(c(xmin = regional_lonlim[1], ymin = regional_latlim[1], 
                         xmax = regional_lonlim[2], ymax = regional_latlim[2]), crs = st_crs(4326)) 
# create a bounding box polygon
regional_polygon <- st_as_sfc(regional_bbox)

# Define the bounding box as an sf object for the study site
studysite_bbox <- st_bbox(c(xmin = studysite_lonlim[1], ymin = studysite_latlim[1], 
                         xmax = studysite_lonlim[2], ymax = studysite_latlim[2]), crs = st_crs(4326))
studysite_polygon <- st_as_sfc(studysite_bbox)

# Loading data  for regional and study site maps  
sf_use_s2(FALSE) # to fix sf error)

# loading land data, repairing invalid geometries and subsetting to map bounding box
land <- ne_countries(scale = 10, returnclass = "sf")
land_data <- land[c("geometry", "continent", "name")] %>%  mutate(type = "Land", type2= "Boundary", label=name, .keep="unused")
land_data_valid <- st_is_valid(land_data, NA_on_exception = TRUE) 
if (any(is.na(land_data_valid) | !land_data_valid)) {
  land_data <- st_make_valid(land_data)}
regional_land_data <- st_intersection(land_data, regional_polygon)

# loading coastline data, repairing invalid geometries and subsetting to map bounding box
coastlines <- ne_coastline(scale = 10, returnclass = "sf")
coastline_data <- coastlines["geometry"] %>% mutate(type = "Land", type2= "Boundary")
coastline_data_valid <- st_is_valid(coastline_data, NA_on_exception = TRUE)
if (any(is.na(coastline_data_valid) | !coastline_data_valid)) {
  coastline_data <- st_make_valid(coastline_data)}
regional_coastline_data <- st_intersection(coastline_data, regional_polygon)

# loading rivers data, repairing invalid geometries and subsetting to map bounding box
rivers <- ne_download(scale = 10, type = "rivers_lake_centerlines", category = "physical", returnclass = "sf")
rivers_data <- rivers[c("geometry", "rivernum", "label")] %>% mutate(type = "Water", type2="Boundary")
rivers_data_valid <- st_is_valid(rivers_data, NA_on_exception = TRUE)
if (any(is.na(rivers_data_valid) | !rivers_data_valid)) {
  rivers_data <- st_make_valid(rivers_data)}
regional_rivers_data <- st_intersection(rivers_data, regional_polygon)

# loading lakes data, repairing invalid geometries and subsetting to map bounding box
lakes <- ne_download(scale = 10, type = "lakes", category = "physical", returnclass = "sf")
lakes_data <- lakes[c("geometry", "label")] %>% mutate(type = "Water", type2="Boundary") 
lakes_data_valid <- st_is_valid(lakes_data, NA_on_exception = TRUE)
if (any(is.na(lakes_data_valid) | !lakes_data_valid)) {
  lakes_data <- st_make_valid(lakes_data)}
regional_lakes_data <- st_intersection(lakes_data, regional_polygon)

#getting high resolution study site data 
studysite_land_data <- st_as_sf(getData('GADM', country='USA', level=0), crs=st_crs(4326)) %>%
  st_intersection(studysite_polygon, dimension="polygon") %>% mutate(type = "Land", type2= "Boundary")
studysite_coastline_data <- st_boundary(studysite_land_data)

# create the point and text for the study site (in the same coordinate system as the map)
study_site <- st_sfc(st_point(c(center_lon, center_lat)), crs = st_crs(4326))
study_site_text <- st_sfc(st_point(c(center_lon, center_lat*1.005)), crs = st_crs(4326)) %>% # nudge up
  st_sf(data.frame(location = location), crs = st_crs(4326))
study_site_text_2 <- st_sfc(st_point(c(center_lon, center_lat*1.0075)), crs = st_crs(4326)) %>% # nudge up
  st_sf(data.frame(location = "STUDY SITE"), crs = st_crs(4326))

# Download and process ocean labels
ocean_labels <- ne_download(type = "geography_marine_polys", category = "physical", scale = 10) %>% 
  st_transform(crs = 4326) %>% 
  st_intersection(regional_polygon) %>%
  st_centroid() %>%
  dplyr::select(label, name_en, geometry)

# Download and process geography labels
geography_labels <- ne_download(type = "geography_regions_polys", category = "physical", scale = 10) %>% 
  st_transform(crs = 4326) %>% 
  st_intersection(regional_polygon) %>%
  st_centroid() %>%
  dplyr::mutate(label = LABEL, name_en=NAME_EN) %>%
  dplyr::select(label, name_en, geometry)

# Combine and categorize labels
all_labels <- rbind(ocean_labels, geography_labels) %>%
  mutate(is_capitalized = toupper(label) == label) %>% 
  mutate(label = ifelse(is_capitalized == FALSE, name_en, label)) %>% 
  dplyr::select(-name_en)

pacific_ocean_index <- which(all_labels$label == "NORTH PACIFIC OCEAN")
all_labels$geometry[pacific_ocean_index] <- st_sfc(st_point(c(st_coordinates(all_labels[pacific_ocean_index, ])[1, 1] - 2, 
                                                              st_coordinates(all_labels[pacific_ocean_index, ])[1, 2] + 2)), 
                                                   crs = st_crs(all_labels))

continental_labels <- which(all_labels$label == "NORTH AMERICA" | all_labels$label == "NORTH PACIFIC OCEAN")
continental_labels <- all_labels[continental_labels, ] %>% 
  mutate(label = case_when(label == "NORTH AMERICA" ~ "NORTH\nAMERICA",
                          label == "NORTH PACIFIC OCEAN" ~ "NORTH\nPACIFIC OCEAN"))

inset_labels <- which(all_labels$label == "Channel Islands of California")
inset_labels <- all_labels[inset_labels, ] %>% 
  mutate(label = "Channel\nIslands")

# Filter out the "ROCKY MOUNTAINS" label
all_labels <- filter(all_labels, label != "ROCKY MOUNTAINS" & label != "NORTH AMERICA"
                     & label != "NORTH PACIFIC OCEAN" & label != "Channel Islands of California")

all_labels <- all_labels %>%
  mutate(label = str_replace_all(label, " ", "\n"))


# Create a regional map with an inset study site
study_site_map <- ggplot() +
  # mapping the regional background data to create boundaries for the map
  #geom_sf(regional_background, mapping=aes(fill=type, color=type), linewidth = 0.2) +
  
  # mapping the regional land and coastline data to create the land area and boundaries
  geom_sf(regional_land_data, mapping=aes(fill=type, color=type), linewidth = 0.2) +
  geom_sf(regional_coastline_data, mapping=aes(color=type2, fill=type2), linewidth = 0.1, alpha=0.8) +
  
    #shading the overlays to add a 3 dimensional look 
  geom_sf(regional_coastline_data, mapping=aes(color=type2),
          fill=NA, color = "darkolivegreen", linewidth = 1, alpha = 0.05) + 
  geom_sf(regional_coastline_data, mapping=aes(color=type2), fill=NA, color = "darkolivegreen", linewidth = 3, alpha = 0.05) +
  geom_sf(regional_lakes_data, mapping=aes(color=type2),
          fill = NA, color="darkolivegreen", size=1.2, linewidth=0.15, alpha=0.05) + 
  geom_sf(regional_rivers_data, mapping=aes(color=type2),
          fill = NA, color="darkolivegreen", size=1.2, linewidth=0.5, alpha=0.75) +
  geom_sf(regional_rivers_data, mapping=aes(color=type2),
          fill=NA, color = "darkolivegreen", size=1.2, linewidth=1, alpha=0.05) + 
  geom_sf(regional_rivers_data, mapping=aes(color=type2),
          fill=NA, color = "darkolivegreen", size=1.2, linewidth=2, alpha=0.05) +
  geom_sf(regional_rivers_data, mapping=aes(color=type2),
          fill=NA, color = "darkolivegreen3", size=1.2, linewidth=1.5, alpha=0.05) +
  geom_sf(regional_coastline_data, mapping=aes(color=type), fill=NA, color = "darkolivegreen3", linewidth = 1.5, alpha = 0.05) +
  geom_sf(regional_rivers_data, mapping=aes(color=type),
          fill=NA, color = "white", size=1.5, linewidth=0.5, alpha=0.05) +
  geom_sf(regional_coastline_data, mapping=aes(color=type),
          fill=NA, color = "white", linewidth = 1.5, alpha = 0.05) +
  geom_sf(regional_coastline_data, mapping=aes(color=type),
          fill=NA, color = "grey20", size=1.5, linewidth=0.075, alpha=0.05) +
  
  # mapping the regional rivers and lakes data with shading (shading first then overlaying river and and lakes)
  geom_sf(regional_rivers_data, mapping=aes(color=type, fill=type), size=0.8, linewidth=0.4) + #inserting rivers
  geom_sf(regional_lakes_data, mapping=aes(color=type, fill=type), size=0.8, linewidth=0.1) + #inserting lakes

  # Adding labels with conditional styling, size, and nudging
  geom_sf_text(data = all_labels, mapping = aes(geometry = geometry, label = label, 
                                              fontface = ifelse(is_capitalized, "bold", "italic")),
             family = "serif", 
             size = ifelse(all_labels$is_capitalized, 1.5,  1.8),  # Larger size for capitalized
             color = "grey30", 
             check_overlap = TRUE, 
             nudge_x = ifelse(all_labels$is_capitalized, 0.5, 0),  # More nudge for capitalized
             nudge_y = ifelse(all_labels$is_capitalized, 0.1, 0)) + # More nudge for capitalized
  geom_sf_text(data= continental_labels, mapping = aes(geometry = geometry, label = label), family = "serif", 
              fontface="bold", size = 2.5, color = "grey30", check_overlap = TRUE, nudge_x = 1) +
  geom_sf_text(data= inset_labels, mapping = aes(geometry = geometry, label = label), family = "serif",
              fontface = "italic", size = 1.5, color = "grey30", check_overlap = TRUE, nudge_x = 0.5, nudge_y=-0.75) +
  
  # adding geom sf insets to create the inset plot 
  geom_inset_frame(target.aes = list(fill = "cyan3")) +
  geom_sf_inset(studysite_land_data, mapping=aes(fill=type), color=NA, linewidth = 0.1, map_base = "none") +
  geom_sf_inset(studysite_coastline_data, mapping=aes(color=type2),
                fill=NA, linewidth = 0.15, alpha = 0.3, map_base = "none") +
  geom_sf_inset(studysite_coastline_data, mapping=aes(color=type),
                fill=NA, color = "darkolivegreen", size=0.8, linewidth = 1, alpha = 0.05, map_base = "none") +
  geom_sf_inset(studysite_coastline_data, mapping=aes(color=type),
                fill=NA, color = "darkolivegreen", size=0.8, linewidth = 3, alpha = 0.05, map_base = "none") +
  geom_sf_inset(studysite_coastline_data, mapping=aes(color=type),
                fill=NA, color = "darkolivegreen3", size=0.8, linewidth = 2, alpha = 0.05, map_base = "none") +
  geom_sf_inset(studysite_coastline_data, mapping=aes(color=type),
                fill=NA, color = "white", size=0.6, linewidth = 0.5, alpha = 0.05, map_base = "none") +
  geom_sf_inset(studysite_coastline_data, mapping=aes(color=type),
                fill=NA, color = "grey20", size=1,linewidth = 0.075, alpha = 0.05, map_base = "none") +
  #insert study site point 
  geom_sf_text_inset(study_site_text_2, label = "STUDY SITE", mapping = aes(), size = 3, 
                  color = 'grey30', family = "serif",
                  fontface="bold", map_base="none", y_nudge = -1) +
  geom_sf_text_inset(study_site_text, label = location, mapping = aes(), size = 2, 
                  color = 'grey30', family = "serif",
                  fontface="bold", map_base="none", y_nudge = 1) +
  geom_sf_inset(study_site, mapping=aes(), color="orange", size=0.01, map_base = "none") +
  geom_inset_frame()+
  geom_rect(data = data.frame(), aes(xmin = regional_lonlim[1], xmax = regional_lonlim[2],
  ymin = regional_latlim[1], ymax = regional_latlim[2]), fill = NA, colour = "grey30", size=1.2, linewidthe=0.2) +
  coord_sf_inset(inset = configure_inset(centre = study_site, scale = 5, units = "km",
                                         translation = c(-360, -280), radius = 60), expand=FALSE, clip="on")  +
  scale_fill_manual(values = c("Land" = "darkolivegreen3", "Boundary" = "#6B8E23", "Water" = "cyan3")) +
  scale_color_manual(values = c("Land" = "darkolivegreen3", "Boundary" = "#6B8E23", "Water" = "cyan3")) +
  scale_x_continuous(breaks = seq(st_bbox(regional_bbox)["xmin"], st_bbox(regional_bbox)["xmax"], by = 4),
                     limits = c(st_bbox(regional_bbox)["xmin"], st_bbox(regional_bbox)["xmax"]), expand=c(0,0)) +
  scale_y_continuous(breaks = seq(st_bbox(regional_bbox)["ymin"], st_bbox(regional_bbox)["ymax"], by = 4),
                     limits = c(st_bbox(regional_bbox)["ymin"], st_bbox(regional_bbox)["ymax"]), expand=c(0,0)) +
  xlab("Longitude") + ylab("Latitude") +
  theme_minimal(base_family="serif") +
  theme(plot.background = element_rect(fill = "white", colour = "white"),
    panel.background= element_rect(fill="cyan3"), panel.grid = element_blank(), panel.border = element_blank(),
    legend.position = "none", 
    axis.title.x = element_text(margin = margin(t = 7.5), size = 13, hjust = 0.5, family="serif"),
    axis.title.y = element_text(margin = margin(r = 7.5), size = 13, vjust = 0.5, family="serif"),  # Same size for both axes
    axis.text = element_text(size = 9, family="serif"),
    plot.margin = margin(t = 1, r = 1, b = 1, l = 1, unit = "cm")) +
  #spatial aware north arrow placement and specification
  annotation_north_arrow(location = "tr", pad_y = unit(0.35, "cm"), pad_x = unit(0.3, "cm"),
                         width=unit(0.6, "cm"), height = unit(0.8, "cm"), which_north = "grid",
                         style = north_arrow_fancy_orienteering(text_family = "serif", text_size=8,
                         text_col="grey30", fill=c("grey30", "white"))) +
   # spatial-aware automagic scale bar
  annotation_scale(location = "br", style="ticks", height = unit(0.15, "cm"), text_family = "serif", pad_x = unit(0.4, "cm")) 

print(study_site_map)

# Save the plot
ggsave(filename = here("Figures", "study_site_map.png"), plot = study_site_map, width = 4.5, height = 6, dpi = 1600)
```

# Analyzing Study Site Environmental Data


Temperature & pH Data from UCSD Shore Stations 1924-2023 (Newport Beach Pier)
 
Carter, Melissa L.; Flick, Reinhard E.; Terrill, Eric; Beckhaus, Elena C.; Martin, Kayla; Fey, Connie L.; Walker, Patricia W.; Largier, John L.; McGowan, John A. (2022). Shore Stations Program, Newport Beach - Balboa Pier. In Shore Stations Program Data Archive: Current and Historical Coastal Ocean Temperature and Salinity Measurements from California Stations. UC San Diego Library Digital Collections. https://doi.org/10.6075/J0GX4BCP

Temperature and pH data provided by the Shore Stations Program sponsored at Scripps Institution of Oceanography by California Department of Parks and Recreation, Natural Resources Division,  Award# C1670003, and pH data provided by the Southern California Coastal Ocean Observing System.

## Temperature Study Site Data 

```{r Temperature Data, message=FALSE, warning=FALSE}

# Read the CSV file
newport_temp <- read_csv(here("Data", "Site_Data", "NewportBeach_TEMP_1924-2023.csv"))

# Data Cleaning and Transformation
# Filter data based on TEMP_FLAG and SURF_TEMP_C values, then create a Date column
newport_temp_data <- newport_temp %>%
  filter(is.na(TEMP_FLAG) | TEMP_FLAG %in% c(0, 5, 6)) %>%
  filter(between(SURF_TEMP_C, 5, 35)) %>%
  mutate(Date = make_date(YEAR, MONTH, DAY)) %>%
  dplyr::select(Date, Temperature = SURF_TEMP_C)

filtered_temp_data <- newport_temp_data %>% 
   dplyr::filter(between(Date, as.Date("2020-01-01"), as.Date("2024-01-01"))) 
  
# Calculate Daily Mean Temperature
daily_temp_stats <- filtered_temp_data %>%
  group_by(Date) %>%
  summarise(Mean_Temp = mean(Temperature, na.rm = TRUE)) %>% 
  na.omit()

#Calculate Monthly Mean Temperature
monthly_temp_stats <- daily_temp_stats %>%
  mutate(Month = lubridate::month(Date, label = TRUE, abbr = TRUE))

ym_temp_stats_summary <- newport_temp_data %>%
  mutate(Month = lubridate::month(Date, label = TRUE, abbr = TRUE)) %>% 
  mutate(YM= zoo::as.yearmon(Date)) %>%
  group_by(Month) %>%
  group_by(YM) %>%
  summarise(
    Mean = mean(Temperature, na.rm = TRUE),
    SD = sd(Temperature, na.rm = TRUE),
    Min = min(Temperature, na.rm = TRUE),
    Max = max(Temperature, na.rm = TRUE),
    N = n(),
    SE = SD / sqrt(N),
    Lower_95CI = Mean - qt(0.975, N - 1) * SE,
    Upper_95CI = Mean + qt(0.975, N - 1) * SE) %>%
  arrange(YM)

# Plotting
temperature_timeseries <- ggplot(ym_temp_stats_summary, aes(x = as.Date(YM), y = Mean)) +
  geom_line(aes(color = Mean), size = 0.25) +
  geom_smooth(method = "lm", se = FALSE, color = "red3", size=0.5) +
  scale_color_gradient(low = "#fed911", high = "red2", limits = c(10, 25), breaks = seq(10, 25, by = 5), name = "Temp") +
  scale_x_date(date_breaks = "10 years", date_labels = "%Y") +
  scale_y_continuous(limits = c(10, 24), breaks = seq(10, 24, by = 2), expand=c(0,0)) +
  common_theme +
  labs(y = "Temperature (°C)", x="Date", color = "Temp (°C)", 
       title = "", subtitle = "")

# Overall and Experimental Mean Temperature Calculation
overall_mean_temp <- mean(daily_temp_stats$Mean_Temp, na.rm = TRUE)
overall_se_temp <- sd(daily_temp_stats$Mean_Temp, na.rm = TRUE) / sqrt(nrow(daily_temp_stats))
experimental_mean_temp <- daily_temp_stats %>%
  filter(between(Date, as.Date("2022-08-01"), as.Date("2022-09-30"))) %>%
  summarise(Experimental_Mean_Temp = mean(Mean_Temp, na.rm = TRUE)) %>%
  pull(Experimental_Mean_Temp)

# Print mean temperatures
cat("Overall mean temperature:", round(overall_mean_temp, 2), "°C\n")
cat("Experimental (Duration) mean temperature:", round(experimental_mean_temp, 2), "°C\n")

hline_data <- data.frame(yintercept = seq(12, 26, by = 2))
hline_data$color_value <- as.factor(hline_data$yintercept)  # gradient mapping
hline_data$yintercept <- hline_data$yintercept


# Define the colors, taking the first eight colors from your list
heat_colors <- c(
   "#fed976", "#ffd480", "#feb24c", "#ff9a17", "#fd8d3c", "#fc4e2a", "#e31a1c", "red3"
)

# Modify the histogram plotting code to reflect these changes
histogram_temp <- gghistostats(
  data = daily_temp_stats,
  x = Mean_Temp,
  binwidth = 0.5,
  bin.args = list(color="#A40000", fill = "#FF4D4D",
                  linewidth = 0.225, alpha=0.95),
  xlab = "Sea Surface Temperature (°C)",
  ylab = "Frequency",
  type = "parametric",
  centrality.plotting = TRUE,
  centrality.type = "parametric",
  centrality.line.args = list(color = "#A40000", size = 0.6, linetype = "dashed"),
    centrality.label.args = list(
      size = 4,  # Smaller font size for centrality labels
      color = "black"  # Example color setting
    ),
  results.subtitle = FALSE,
  ggplot.component= list(geom_vline(data = hline_data, aes(xintercept = yintercept,
                                                           color = color_value),
                               linewidth = 0.4, linetype="dashed")))  +
  scale_color_manual(values = heat_colors) +
xlab("Temperature (°C)") +
ylab("Frequency") +
scale_y_continuous(
  name = "Frequency",
  limits=c(0,125),
  sec.axis = sec_axis(~., name = NULL, labels=NULL), expand=c(0,0)) +
theme(plot.title = element_blank(), plot.subtitle = element_blank(), legend.position = "none") +
common_theme

# Ensure the Month column is a factor and in the right order for plotting
monthly_temp_stats$Month <- factor(monthly_temp_stats$Month,
levels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))

# Create the plot
temp_violin_plot <- ggplot(monthly_temp_stats, aes(x = Month, y = Mean_Temp, fill=Month)) +
  geom_hline(data = hline_data, aes(yintercept = yintercept,
                                    color = color_value), size = 0.3) +
 # geom_violin(trim = FALSE, scale="width", color="#8B0000", linewidth = 0.25) +
  geom_violin(trim = FALSE, scale="width", color="#A40000", fill="#FF4D4D",
              linewidth = 0.225) +
  geom_boxplot(width = 0.2, outlier.shape = NA, color=NA, fill="white",
               alpha=0.5) +
  geom_boxplot(width = 0.2, outlier.shape = NA, color="#A40000", fill=NA,
               alpha=0.6, linewidth = 0.2) +
  scale_color_manual(values = heat_colors) +
  common_theme +
  scale_y_continuous(breaks = seq(10, 28, by = 2), limits = c(10, 28), expand=c(0,0)) +
  #geom_text(stat="count", aes(label=paste0("(N=",..count..,")")), y=.35*max(monthly_temp_stats$Mean_Temp), family = "serif", 
           # color="black", size =3) +
  labs(x = NULL, y = "Temperature (°C)") 

# Display the plots
print(histogram_temp)
print(temp_violin_plot)
print(temperature_timeseries)

# Assuming 'histogram_temp' is your ggplot object
ggsave(filename = here("Figures", "temp_timeseries.png"), plot = temperature_timeseries, width = 4.5, height = 3, dpi = 1200)
ggsave(filename = here("Figures", "daily_temp_histogram.png"), plot = histogram_temp, width = 4.5, height = 3, dpi = 1200)
ggsave(filename = here("Figures", "monthly_temp_violin_heat_colors.png"), plot = temp_violin_plot, width = 4.5, height = 3, dpi = 1200)

```

## pH Study Site Data 

```{r pH Data, warning=FALSE, message=FALSE}
# Read the CSV file
newportbeach_pH <- read_csv(here("Data", "Site_Data", "Newport_pH_2020-2024.csv"))
# Read and preprocess data
newportbeach.pH.hourly <- read_csv(here("Data", "Site_Data", "Newport_pH_2005-2024.csv"))

# Data Cleaning and Transformation for pH data
filtered_pH_data <- newportbeach_pH %>%
    mutate(pH = sea_water_ph_reported_on_total_scale_salinity_corrected,
         time = as.POSIXct(time, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC"),
         Date = as.Date(time)) %>%
  filter(sea_water_ph_reported_on_total_scale_salinity_corrected_qc_agg == 1) %>% 
  filter(Date >= as.Date("2020-01-01") & Date <= as.Date("2024-01-01")) %>% 
  dplyr::select(Date, time, pH) %>%  # Rename PH to pH for clarity
  na.omit()

filtered.newportbeach.pH.hourly <- newportbeach.pH.hourly %>%
   mutate(pH = sea_water_ph_reported_on_total_scale_salinity_corrected,
         time = as.POSIXct(time, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC"),
         Date = as.Date(time)) %>%
  filter(sea_water_ph_reported_on_total_scale_salinity_corrected_qc_agg == 1) %>% 
  filter(Date >= as.Date("2020-01-01") & Date <= as.Date("2024-01-01")) %>% 
  filter(pH > 7.25 & pH <= 8.5) %>%
  dplyr::select(Date, time, pH) %>%
  arrange(time) %>% 
  mutate(gap = c(0, diff(time) > hours(6)),  # Create a logical vector where TRUE indicates a gap
         group = cumsum(gap)) %>% na.omit()

# Calculate 3-hour mean and confidence intervals
six_hour_ph_stats <- filtered.newportbeach.pH.hourly %>%
  mutate(SixHourInterval = floor_date(time, "6 hours")) %>%
  group_by(group, SixHourInterval) %>%
  summarise(
    Mean = mean_pH(pH, na.rm = TRUE),
    SD = sd(pH, na.rm = TRUE),
    N = n(),
    SE = ifelse(N > 1, SD / sqrt(N), NA),
    Lower_95CI = ifelse(N > 1, Mean - qt(0.975, N - 1) * SE, NA),
    Upper_95CI = ifelse(N > 1, Mean + qt(0.975, N - 1) * SE, NA)
  ) %>%
  ungroup() %>%  # Ungroup for plotting
  na.omit()

# Calculate Daily Mean pH
daily_pH_stats <- filtered_pH_data %>%
  group_by(Date) %>%
  summarise(Mean_pH = mean_pH(pH, na.rm = TRUE)) %>% 
  na.omit() %>% 
  filter(Mean_pH > 7.25 & Mean_pH < 8.5)

#Calculate Monthly Mean pH (Adjust column names as necessary)
monthly_pH_stats <- daily_pH_stats %>%
  mutate(Month = lubridate::month(Date, label = TRUE, abbr = TRUE)) %>% 
  na.omit()

# mean pH calculations 
overall_mean_pH <- mean(daily_pH_stats$Mean_pH, na.rm = TRUE)
# Print mean temperatures
cat("Overall mean pH:", round(overall_mean_pH, 2), "°C\n")

# pH plot timeseries with IQR lines and overall mean
pH_timeseries <- ggplot(six_hour_ph_stats, aes(x = SixHourInterval, y = Mean, group=group)) +
  geom_line(aes(color = Mean), size = 0.25) +
  geom_hline(yintercept = overall_mean_pH, linetype = "dashed",
             color = "darkcyan", size = 0.5,
             alpha=0.5) +
  scale_color_gradient(low = "cyan3", high = "darkcyan",
                       limits = c(7.25, 8.5), breaks = seq(7.325, 8.5, by = 0.25), name = "pH") +
  scale_x_datetime(date_breaks = "1 year", date_labels = "%b %Y") +
  scale_y_continuous(limits = c(7.25, 8.5), breaks = seq(7.25, 8.5, by = 0.25), expand=c(0,0)) +
  common_theme +
  labs(x = "Date", y = TeX("$pH_{T}$"),
       title = "", subtitle = "")

# 'pH_values' with experimental treatment values
pH_values <-  data.frame(xintercept = c(7.7, 7.9))  # Experiemtnal treatment values
pH_values$color_value <- as.factor(pH_values$xintercept)  # gradient mapping
max_value_pH <- max(daily_pH_stats$Mean_pH, na.rm = TRUE) 
total_observations_pH <- nrow(daily_pH_stats)

pH_colors = c("cyan3", "orange")

# Now, creating the histogram for pH
histogram_pH <- gghistostats(
  data = daily_pH_stats,
  x = Mean_pH,
  binwidth = 0.04,
  bin.args = list(color = "darkcyan", fill = "cyan3", linewidth=0.225, alpha=0.95),
  xlab = TeX("$pH_{T}$"),
  ylab = "Frequency",
  type = "parametric",
  centrality.plotting = TRUE,
  centrality.type = "parametric",
  centrality.line.args = list(color = "#007070", size = 0.6, linetype = "dashed"),
  centrality.label.args = list(
      size = 4,  # Smaller font size for centrality labels
      color = "black"  # Example color setting
    ),
  results.subtitle = FALSE, 
  ggplot.component = list(
    geom_vline(data = pH_values, aes(xintercept = xintercept, color = color_value),
               linetype = "dashed", linewidth = 0.4))) +
  scale_color_manual(values = pH_colors) +
  xlab(TeX("$pH_{T}$")) +
  ylab("Frequency") +
  scale_y_continuous(name = "Frequency",
  limits = c(0, 350), breaks = seq(0, 350, by = 50),
  sec.axis = sec_axis(~., name = NULL, labels=NULL), expand=c(0,0)) +
theme(plot.title = element_blank(), plot.subtitle = element_blank(), legend.position = "none") +
common_theme

# Merge the calculated positions back into the original data frame
monthly_pH_stats <- merge(monthly_pH_stats, label_positions, by = "Month")



monthly_colors <- c("#00B5B5", "#00AAAA", "#00A0A0", "darkcyan", "#008B8B", "#00AAAA", "#00BFBF", "#00CACA", "#00D4D4", "#00E9E9", "#00E9E9", "#00DFDF")

# Ensure the Month column is a factor and in the right order for plotting
monthly_pH_stats$Month <- factor(monthly_pH_stats$Month,
levels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))

# Adapting the plotting steps for pH data
pH_violin_plot <- ggplot(monthly_pH_stats, aes(x = Month, y = Mean_pH, fill= Month)) +
  geom_hline(data = pH_values, aes(yintercept = xintercept, color = color_value),
             size = 0.3) +
 # geom_violin(trim = FALSE, scale="width", color="black", linewidth = 0.2) +
  geom_violin(trim = FALSE, scale="width", color="darkcyan", fill="cyan3",
              linewidth = 0.225) +
  geom_boxplot(width = 0.2, outlier.shape = NA, color=NA, fill="white",
               alpha=0.5) +
  geom_boxplot(width = 0.2, outlier.shape = NA, color="darkcyan", fill=NA,
               alpha=0.6, linewidth = 0.2) +
  scale_color_manual(values = pH_colors) +
  common_theme +
  theme(plot.title = element_blank(),
        plot.subtitle = element_blank(),legend.position = "none"
       # plot.margin = margin(t = 0.5, r = 2, b = 0.5, l = 0.5, unit="cm")
        ) +
  xlab("Month") + 
  ylab(TeX("$pH_{T}$")) +
  #geom_text(stat="count", aes(label=paste0("(N=",..count..,")")),
            #y=.8612*max(monthly_pH_stats$Mean_pH), family = "serif",
            #color="black", size =3) +
  scale_y_continuous(breaks = seq(7.25, 8.5, by = 0.25),
                     limits=c(7.25,8.5), expand=c(0,0)) # +
  #expand_limits(y=.86125*max(monthly_pH_stats$Mean_pH))

# Print the plots
print(pH_timeseries)
print(pH_violin_plot)
print(histogram_pH)

# Save the plot if needed
ggsave(filename = here("Figures", "monthly_pH_violin_plot.png"), plot = pH_violin_plot, width = 4.5, height = 3, dpi = 1200)
ggsave(filename = here("Figures", "daily_pH_histogram.png"), plot = histogram_pH, width = 4.5, height = 3, dpi = 1200)
ggsave(filename = here("Figures", "pH_timeseries.png"), plot = pH_timeseries, width = 4.5, height = 3, dpi = 1200)

```

## Combining Plot 

```{r, warning=FALSE, message=FALSE}

histogram_temp <- histogram_temp + 
  theme(plot.margin =margin(l = 0.2, r = 0.2, t = 0.8, b = 0.2, unit = "cm"),
        axis.title.y = element_text(size = 13, margin = margin(r = 10)),
        axis.text.y = element_text(size = 9),
        axis.title.x = element_text(size = 13),
        axis.text.x = element_text(size = 9)
        ) 
histogram_pH <- histogram_pH +
  theme(plot.margin =margin(l = 0.2, r = 0.2, t = 0.8, b = 0.4, unit = "cm"),
        axis.title.y = element_text(size = 13, margin=margin(r = 15)),
        axis.text.y = element_text(size = 9),
        axis.title.x = element_text(size = 13),
        axis.text.x = element_text(size = 9)
        )


combined_histograms <- cowplot::plot_grid(histogram_temp, histogram_pH,
                                          labels = c("(A)", "(B)"),
  label_size = 16,  # Adjust label size
  hjust = -0.15,  # Adjust horizontal justification
  label_fontfamily = "serif",  # Set label font family to serif
  axis = 'tblr',  # Reduce the gap by aligning top and bottom
  rel_heights = c(3, 3),
  ncol = 1, rel_widths = c(4, 4))
print(combined_histograms)
ggsave(filename = here("Figures", "combined_histograms.png"), plot = combined_histograms, width = 6, height = 6, dpi = 1400)

pH_violin_plot <- pH_violin_plot + 
  theme(plot.margin =margin(l = 0.2, r = 0.4, t = 1.15, b = 0.6, unit = "cm"),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 10.5),
        axis.title.x = element_text(size = 14),
        axis.text.x = element_text(size = 10.5))
temp_violin_plot <- temp_violin_plot +
  theme(plot.margin =margin(l = 0.25, r = 0.4, t = 1.15, b = 0.2, unit = "cm"),
        axis.title.y = element_text(size = 14, margin = margin(r = 10)),
        axis.text.y = element_text(size = 10.5),
        axis.title.x = element_text(size = 14, margin = margin(r = 5)),
        axis.text.x = element_text(size = 10.5))

combined_violin_plots <- cowplot::plot_grid(temp_violin_plot, pH_violin_plot,
                                           labels = c("(B)", "(C)"),
  label_size = 16,  # Adjust label size 
  hjust = -0.15,  # Adjust horizontal justification
  label_fontfamily = "serif",  # Set label font family to serif
  axis = 'tblr',  # Reduce the gap by aligning top and bottom
  rel_heights = c(2, 2.25),
  ncol = 1, rel_widths = c(4.5, 4.25))

study_site_map_adjusted <- study_site_map +
  theme(plot.margin = margin(l = 0.15, r = 0.65, t = 1, b = 0.575, unit = "cm"),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 11),
        axis.title.x = element_text(size = 14),
        axis.text.x = element_text(size = 11))
  
combined_plot <- cowplot::plot_grid(study_site_map_adjusted, combined_violin_plots, 
                                    labels = c("(A)", ""),
                                    label_size = 16, hjust = -0.15,
                                    label_fontfamily = "serif",
                                    rel_widths = c(4.2, 4.6),
                                    ncol = 2, axis = 'tblr') +
  theme(plot.background = element_rect(fill = "white", colour = "white"))

ggsave(filename = here("Figures", "combined_study_plot.png"), plot = combined_plot, width = 8.4, height = 6, dpi = 1400)


```

# Mesocosm Carbonate System Calculations & Temperature Logger (HOBO) Data Analysis 

Reading in pH calibration data and calculating pH and reading in total alkalinity data to calcualte carbinate system parameters within the mesocosm system

```{r Mesocosm pH, Total Alkalinity, and Carbonate System Calculations, warning=FALSE, message=FALSE}

# Read in daily mesocosm data 
mesocosm_daily_data <- read_csv(here("Data", "Mesocosm_Data", "Mesocosm_Daily_Datasheet.csv"),
  show_col_types = FALSE) %>%
  mutate(Date = mdy(Date), 
         Tank_ID = as.factor(Tank_ID), 
         pH_Treatment = as.factor(pH_Treatment), 
         Temp_Treatment = as.factor(Temp_Treatment))

# Read pH calibration data
pHcalib <- read_csv(here("Data", "Mesocosm_Data", "TrispHcalibration.csv"), show_col_types = FALSE) %>%
  mutate(TrisCalDate = ymd(TrisCalDate))

# Read mesocosm daily datasheet and select relevant columns
pHData <- read_csv(here("Data", "Mesocosm_Data", "Mesocosm_Daily_Datasheet.csv"),
  show_col_types = FALSE) %>%
  mutate(TrisCalDate = ymd(TrisCalDate),
         Date = mdy(Date), 
         Temp_Treatment = as.factor(Temp_Treatment), 
         pH_Treatment = as.factor(pH_Treatment),
         Tank_ID = as.factor(Tank_ID)) %>% 
  dplyr::select(Temp_C, mV, Salinity, TrisCalDate, Date, Tank_ID, pH_Treatment, Temp_Treatment)

# Calculate pH values using calibration data
pHSlope <- pHcalib %>%
  group_by(TrisCalDate) %>%
  summarise(fitpH = list(lm(mVTris ~ TTris, data = cur_data()))) %>%
  mutate(tidy_fit = purrr::map(fitpH, broom::tidy)) %>%
  unnest(tidy_fit) %>%
  dplyr::select(TrisCalDate, term, estimate) %>%
  pivot_wider(names_from = term, values_from = estimate)

# Join pH calibration data with daily mesocosm data
pHjoined <- left_join(pHData, pHSlope, by = "TrisCalDate") %>%
  mutate(mVTris_calc = Temp_C * TTris + `(Intercept)`) %>%
  drop_na(Temp_C, mV)

# Calculate pH
pHcalc <- pHjoined %>%
  mutate(pH = seacarb::pH(Ex = mV, Etris = mVTris_calc, S = Salinity, T = Temp_C)) %>%
   dplyr::select(Date, Tank_ID, pH_Treatment, Temp_Treatment, pH)

# Read and process Total Alkalinity (TA) data
read_process_TA_data <- function(file_path, date, start_date, end_date) {
  read_csv(file_path, show_col_types = FALSE) %>% 
    mutate(Date = as.Date(date),
           Start_Date = as.Date(start_date),
           End_Date = as.Date(end_date)) %>%
    rename(Tank_ID = SampleID) %>%
    mutate(Tank_ID = gsub("-", "_", Tank_ID),
           Tank_ID = gsub("TNK_SUMP", "TNK_SMP", Tank_ID)) %>%
    group_by(Tank_ID) %>%
    do({
      df <- .
      dates <- seq(.$Start_Date, .$End_Date, by = "day")
      df[rep(seq_len(nrow(df)), each = length(dates)), ] %>%
        mutate(Date = dates)
    }) %>%
    ungroup() %>%
    dplyr::select(Date, Tank_ID, TA, TA_evap)
}

# Read and process TA data for different dates
TAdata_combined <- bind_rows(
  read_process_TA_data(here("Data", "Mesocosm_Data", "Total_Alkalinity", "TA2022-09-01.csv"), "2022-09-01", "2022-08-27", "2022-09-01"),
  read_process_TA_data(here("Data", "Mesocosm_Data", "Total_Alkalinity", "TA2022-08-22.csv"), "2022-08-22", "2022-08-22", "2022-08-26"),
  read_process_TA_data(here("Data", "Mesocosm_Data", "Total_Alkalinity", "TA2022-08-16.csv"), "2022-08-16", "2022-08-16", "2022-08-21")
) %>%
  filter(Tank_ID != "CRM",
         Tank_ID != "Junk") %>% 
   dplyr::select(Date, Tank_ID, TA) %>%
  arrange(Date, Tank_ID)

# Merge TA and pH data
completed_meso_data <- left_join(mesocosm_daily_data, pHcalc, by = c("Date", "Tank_ID", "pH_Treatment", "Temp_Treatment")) %>%
  left_join(TAdata_combined, by = c("Date", "Tank_ID"))

# Convert TA from µmol/kg to mol/kg
completed_meso_data <- completed_meso_data %>% 
  mutate(TA = as.numeric(TA * 1e-6))

# Initialize columns for carbonate system parameters
completed_meso_data$pCO2 <- NA
completed_meso_data$pCO2insitu <- NA
completed_meso_data$HCO3 <- NA
completed_meso_data$CO3 <- NA
completed_meso_data$DIC <- NA

# Calculate carbonate system parameters
for (i in 1:nrow(completed_meso_data)) {
  pH <- completed_meso_data$pH[i] 
  TA <- completed_meso_data$TA[i]  
  Salinity <- completed_meso_data$Salinity[i] 
  Temp_C <- completed_meso_data$Temp_C[i] 
  
  carbonate_params <- seacarb::carb(flag = 8, var1 = pH, var2 = TA, S = Salinity,
                            T = Temp_C, Patm = 1, P = 0, Pt = 0, Sit = 0, k1k2 = "l", kf = "pf", ks = "d",
                            pHscale = "T", b = "u74", warn = "y")
  
  completed_meso_data$pCO2[i] <- carbonate_params$pCO2
  completed_meso_data$pCO2insitu[i] <- carbonate_params$pCO2insitu
  completed_meso_data$HCO3[i] <- carbonate_params$HCO3
  completed_meso_data$CO3[i] <- carbonate_params$CO3
  completed_meso_data$DIC[i] <- carbonate_params$DIC
}

# Convert parameters to µmol/kg
completed_meso_data <- completed_meso_data %>% 
  mutate(TA = TA * 1e6,
         HCO3 = HCO3 * 1e6,
         CO3 = CO3 * 1e6,
         DIC = DIC * 1e6)

# Write the data
write_csv(completed_meso_data, here("Data", "Mesocosm_Data", "Completed_Mesocosm_Dataset_Carbonate.csv"))

# Calculate the overall mean pH
low_mean_pH <- completed_meso_data %>% 
  filter(pH_Treatment == "Low") %>%
  dplyr::summarize(Mean_pH = mean_pH(pH, na.rm = TRUE),
                   SD_pH = sd(pH, na.rm = TRUE),
                   N = n(),
                   SE = SD_pH / sqrt(N),
                   Upper_CI = Mean_pH + 1.96 * SE,
                   Lower_CI = Mean_pH - 1.96 * SE)

# Calculate the overall mean pH
ambient_mean_pH <- completed_meso_data %>% 
  filter(pH_Treatment == "Ambient") %>%
  dplyr::summarize(Mean_pH = mean_pH(pH, na.rm = TRUE),
                   SD_pH = sd(pH, na.rm = TRUE),
                   N = n(),
                   SE = SD_pH / sqrt(N),
                   Upper_CI = Mean_pH + 1.96 * SE,
                   Lower_CI = Mean_pH - 1.96 * SE)

cat("Low pH Treatment Mean pH: ", low_mean_pH$Mean_pH, "\n")
cat("Ambient pH Treatment Mean pH: ", ambient_mean_pH$Mean_pH, "\n")

```

## Summary Table for Mesocosm 




```{r}
# Preparing the data, filtering out unnecessary records
gt_meso_summary <- completed_meso_data %>%
  filter(pH_Treatment != "Sump", 
         Temp_Treatment != "10",
         Date != "2022-08-16") %>%
  select(Temp_Treatment, pH_Treatment, Temp_C, pH, DO_mgL, Salinity,
         TA, pCO2, HCO3, CO3, DIC) %>% 
  ungroup()

# Prepare the data by ensuring factors are set correctly (if not already)
gt_meso_summary$Temp_Treatment <- factor(gt_meso_summary$Temp_Treatment, levels = c("12", "14", "16", "18", "20", "22", "24", "26"))
gt_meso_summary$pH_Treatment <- factor(gt_meso_summary$pH_Treatment, levels = c("Ambient", "Low"))

gt_meso_summary <- gt_meso_summary %>%
  mutate(TA = as.numeric(as.character(TA)))



# Function to select treatment variables and summarize any specified variable with custom labeling
select_and_summarize_variable <- function(data, variable, variable_label) {
  # Check if the variable exists in the dataframe
  if (!variable %in% names(data)) {
    stop(paste("the column", variable, "does not exist in the dataframe"))
  }
  
  # Select the columns
  selected_data <- data %>%
    select(Temp_Treatment, pH_Treatment, all_of(variable))  %>%
  mutate(Temp_Treatment = paste(Temp_Treatment, "ºC"))
  
  
  # Summarize the specified variable with a custom label
  summary_table <- selected_data %>%
    tbl_custom_summary(
      by = Temp_Treatment,
      include = "pH_Treatment",
      type= all_continuous() ~ "continuous",
      statistic = pH_Treatment ~ "{mean} ± {sem}",
      stat_fns = ~ continuous_summary(variable),
      digits = everything() ~ 2, 
      label = ~ gt::html(paste(variable_label))
    )  %>% 
    add_stat_label(label = everything() ~ "Mean ± SE") %>%
      bold_labels() %>% 
      modify_header(list(label ~ "**Variable**", all_stat_cols() ~ "**{level}**")) %>% 
    modify_footnote(update = all_stat_cols() ~ "statistic presented is the mean ± standard error.")  %>%
  modify_spanning_header(all_stat_cols() ~ "**Temperature Treatment**") 
  
  
  return(summary_table)
}


result_temp_c <- select_and_summarize_variable(
  gt_meso_summary, "Temp_C", "Temperature&nbsp;(°C)")
result_pH <- select_and_summarize_variable(
  gt_meso_summary, "pH", "pH<sub>T</sub>")
result_DO_mgL <- select_and_summarize_variable(
  gt_meso_summary, "DO_mgL", "DO&nbsp;(mg&nbsp;L<sup>-1</sup>)")
result_salinity <- select_and_summarize_variable(
  gt_meso_summary, "Salinity", "Salinity&nbsp;(ppt)")
result_TA <- select_and_summarize_variable(
  gt_meso_summary, "TA", "TA&nbsp;(µmol&nbsp;kg<sup>-1</sup>)")
result_pCO2 <- select_and_summarize_variable(
  gt_meso_summary, "pCO2", "pCO<sub>2</sub>&nbsp;(µatm)")
result_HCO3 <- select_and_summarize_variable(
  gt_meso_summary, "HCO3", "HCO<sub>3</sub><sup>−</sup>&nbsp;(µmol&nbsp;kg<sup>-1</sup>)")
result_CO3 <- select_and_summarize_variable(
  gt_meso_summary,
  "CO3", "CO<sub>3</sub><sup>2−</sup>&nbsp;(µmol&nbsp;kg<sup>-1</sup>)")
result_DIC <- select_and_summarize_variable(
  gt_meso_summary, "DIC", "DIC&nbsp;(µmol&nbsp;kg<sup>-1</sup>)")


# Stack the tables
# Stack the tables
tbl_stack_mesocosm <- tbl_stack(list(
  result_temp_c, 
  result_pH, 
  result_DO_mgL, 
  result_salinity, 
  result_TA, 
  result_pCO2, 
  result_HCO3, 
  result_CO3, 
  result_DIC
))  %>%
  as_gt() %>%
  text_transform(
    locations = cells_body(),
    fn = function(x) {
      gsub(", Mean ± SE", "", x)
    }
  ) %>% 
  tab_options(row_group.as_column = TRUE)  %>% 
  tab_style(
    style = list(cell_fill(color = "lightcyan")),
    locations = cells_body(columns = everything(),
                           rows = c(3,6,9, 12, 15, 18, 21, 24, 27))
  ) %>% 
  tab_style(
    style = list(cell_fill(color = "#F9E3D6")),
    locations = cells_body(columns = everything(),
                           rows = c(2,5,8, 11, 14, 17, 20, 23, 26)))%>% 
  #cols_nanoplot(
  #  columns = stat_1,
   # new_col_name = "nanoplots",
  #  plot_type = "bar",
  #  new_col_label = md("*Progression*")
 # ) 
  #gt(rownames_to_stub = TRUE) %>% 
    cols_align(
    align = "center",
    columns = everything()
  ) %>%
  gt::tab_style(
    style = "vertical-align:top",
    locations = gt::cells_body(columns = label)
  )  %>% 
  opt_table_font(font = "serif") %>% 
gt::tab_header(
title = gt::md("**Summary of Mesocosm Treatment Conditions**"),
subtitle = gt::md("**Mean ± SE Amongst Temperature and pH Treatments**")) %>%
  gt::tab_style(
    style = gt::cell_text(color = "black", font = "serif", size = 12),
    locations = gt::cells_body()) %>%
  gt::tab_style(
    style = gt::cell_text(weight = "bold", font = "serif", size = 14),
    locations = gt::cells_column_labels(columns = everything())
  ) %>%
  gt::tab_options(
    heading.title.font.size = 20,
    heading.subtitle.font.size = 16,
    table.width = px(500),
    table.font.color="black",
    table.align = "center",
    heading.padding = px(5),
      table.border.top.width = px(1),
    table.border.top.color = "black",
    table.border.bottom.color = "black",
    table.border.bottom.width = px(2),
    table_body.border.bottom.width = px(2),
    table_body.border.bottom.color = "black",
    table_body.border.top.width = px(2),
    table_body.border.top.color = "black",
    table_body.hlines.width = px(0.5),
    table_body.hlines.color = "grey90",
    column_labels.background.color = "white",
    column_labels.border.top.width = px(2),
    column_labels.border.top.color = "black",
    column_labels.border.bottom.width = px(2),
    column_labels.border.bottom.color = "black",
    row_group.border.top.width = px(1.25),
    row_group.border.top.color = "black",
    row_group.border.bottom.width = px(1.25),
    row_group.border.bottom.color = "black",
    source_notes.font.size = 12,
  ) %>% 
  tab_style(
    style = list(
      cell_css = "white-space: nowrap;"
    ),
    locations = cells_body()
  ) %>% fmt_number(
    columns = everything(),
    decimals = 2) %>%
  tab_style(
    style=list(cell_text(align = "center",
                      font = "serif", weight="bolder",
                      size = 14, color = "black"), 
        cell_fill(color = "grey50", alpha = 0.01),
        cell_borders(
        sides = "top", 
        color = "black",
        weight = px(2)
        )),
    locations = cells_title(groups = "title")
  ) %>%
  tab_style(
    style=list(cell_text(align = "center",
                      font = "serif",
                      size = 12, color = "black"), 
        cell_fill(color = "grey50", alpha = 0.01),
        cell_borders(
        sides = "bottom", 
        color = "black",
        weight = px(2)
        )),
    locations = cells_title(groups = "subtitle")
  ) %>%
    tab_style(
    style = cell_text(align = "center", font = "serif", weight="bold", size = 12, color = "black"),
    locations = cells_column_labels(columns = everything()) 
  ) %>%
  tab_style(
    style = cell_text(align = "center", font = "serif", size = 12, color = "black"),
    locations = cells_body()
  )
  

print(tbl_stack_mesocosm)
gtsave(tbl_stack_mesocosm, here("Figures", "gt_table_mesocosm_summary.png"))


```



```{r Mesocosm Carbonate System and Temperature Data Analysis, warning=FALSE, message=FALSE}

mesocosm.data <- read_csv(here("Data", "Mesocosm_Data", "Completed_Mesocosm_Dataset_Carbonate.csv"), show_col_types = FALSE) %>% 
  filter(pH_Treatment != "Sump") %>%  # Filter out rows where pH_Treatment is "Sump"
  filter(!Date == "2022-08-16") %>%  # Filter out specific date
  mutate(Temp_Treatment = as.factor(Temp_Treatment),
         pH_Treatment = as.factor(pH_Treatment))

# Calculate mean and standard deviation of pH by treatment
ph.summary <- mesocosm.data %>%
  filter(pH_Treatment != "Sump") %>% 
  dplyr::select(pH, pH_Treatment) %>% 
  group_by(pH_Treatment) %>%
  summarize(Mean_pH = mean(pH, na.rm = TRUE),
            Sd_pH = sd(pH, na.rm = TRUE))

print(ph.summary)

#pH Anova Test
mesocosm_pH_lm_model <- lm(pH ~ Temp_Treatment * pH_Treatment, data = mesocosm.data)
anova_mescososm_pH_results <- anova(mesocosm_pH_lm_model)
print(anova_mescososm_pH_results)
check_model(mesocosm_pH_lm_model)

# Perform t-test to compare means
t_test_result <- t.test(pH ~ pH_Treatment, data = mesocosm.data)

# Print the t-test results
#print(t_test_result)

# Convert t-test result to a tidy tibble and apply conditional formatting
t_test_table <- tidy(t_test_result) %>%
  format_p_values() 

# Remove periods from the column names and clean up data frame
colnames(t_test_table) <- gsub("\\.", "", colnames(t_test_table))
colnames(t_test_table) <- tools::toTitleCase(colnames(t_test_table))

t_test_table <- t_test_table %>% 
  dplyr::mutate(
          Estimate1 = signif(Estimate1, digits = 2),
          Estimate2 = signif(Estimate2, digits = 2),
          Estimate = signif(Estimate, digits = 2),
          Pvalue = Pvalue,
          Tvalue= signif(Statistic, digits = 2),
          Confhigh = signif(Confhigh, digits = 2), 
          Conflow = signif(Conflow, digits = 2),
          CI = paste(Conflow,"-",Confhigh),
          df=signif(Parameter, digits = 2)) %>% 
  dplyr::select(-Conflow, -Confhigh, -Statistic,
                -Parameter) %>% 
  dplyr::select(Method, Estimate1, Estimate2, Estimate,
                CI, Tvalue, Pvalue, df)
  
         
# Create the gt table and format
t_test_gt_table <- t_test_table %>% 
  gt() %>%
  tab_header(
    title = md("**Summary of Welch Two Sample T-Test for pH Treatments**"),
    subtitle = md("Comparison of pH Conditions: Ambient vs. Low")
  ) %>%
  cols_label(
    Method = "Method",
    Estimate1 = "Mean pH (Ambient)",
    Estimate2 = "Mean pH (Low)",
    Estimate = "Difference Estimate",
    CI = "95% CI",
    Tvalue = "T-Value",
    Pvalue = "P-Value",
    df = "Degrees of Freedom"
  ) %>% gt_theme


print(t_test_gt_table)
# save the gt tables 
gtsave(t_test_gt_table, here("Figures", "gt_table_ttest_pH.png"))


# Temperature Anova Test
mesocosm_temp_lm_model <- lm(Temp_C ~ Temp_Treatment * pH_Treatment, data = mesocosm.data)

# Perform ANOVA on the model
anova_mescososm_temp_results <- anova(mesocosm_temp_lm_model)
print(anova_mescososm_temp_results)
check_model(mesocosm_temp_lm_model)

anova_df <- tidy(anova_mescososm_temp_results) %>% 
  format_p_values() 
  
anova_df <- anova_df %>%   
  mutate(
    statistic = signif(statistic, digits = 2),
    term = gsub("_", " ", term),# Replace underscores with spaces 
    term = tools::toTitleCase(term),  # Capitalize terms
    # Round statistical metrics to two significant figures
    sumsq = signif(sumsq, digits = 2),
    meansq = signif(meansq, digits = 2)
  ) 

anova_df <- anova_df %>%
  mutate(across(everything(), ~ ifelse(is.na(.), "", .))) %>%
  dplyr::select(term, p.value, statistic, sumsq, meansq, df) 

#print(anova_df)

# Perform a Tukey's HSD test
tukey_result <- TukeyHSD(aov(Temp_C ~ Temp_Treatment * pH_Treatment, data = mesocosm.data))

tukey_df <- broom::tidy(tukey_result) 

# Filter Tukey results for "Low" vs "Ambient"
tukey_filtered <- tukey_df %>%
  mutate(
    adj.p.value = as.numeric(adj.p.value)
  ) %>%
  filter(grepl("Low", contrast) & grepl("Ambient", contrast)) %>%
  dplyr::select(comparison = contrast, diff = estimate, lwr = conf.low, upr = conf.high, `p.adj` = adj.p.value) %>%
  dplyr::arrange(p.adj) %>%
  mutate(
    NumberLow = as.numeric(str_extract(comparison, "^\\d+")),  # Get number before ':Low'
    NumberAmbient = as.numeric(str_extract(comparison, "\\d+(?=:Ambient$)"))  # Get number before ':Ambient'
  ) %>%
  filter(!is.na(NumberLow) & !is.na(NumberAmbient), NumberLow == NumberAmbient) %>%
  dplyr::select(comparison, diff, lwr, upr, p.adj) %>%
  arrange(comparison)

#print(tukey_filtered)

# Create the GT table for ANOVA results
energy_anova_gt_table <- gt(anova_df) %>%
  tab_header(
    title = md("**ANOVA Results for Temperature by Treatment**"),
    subtitle = md("Interaction Effects of Temperature and pH Treatments")
  ) %>%
  cols_label(
    term = "Term",
    df = "Degrees of Freedom",
    sumsq = "Sum of Squares",
    meansq = "Mean Square",
    statistic = "F-Value",
    p.value = "P-Value"
  ) %>%
  gt_theme

# Create the GT table for Tukey results
energy_tukey_gt_table <- gt(tukey_filtered) %>%
  tab_header(
    title = md("**Tukey HSD Post Hoc Test Results for Temperature by Treatment**"),
    subtitle = md("Specific Comparisons Between pH Treatments Across Temperatures")
  ) %>%
  cols_label(
    comparison = "Comparison",
    diff = "Difference",
    lwr = "Lower Bound",
    upr = "Upper Bound",
    p.adj = "Adjusted P-Value"
  ) %>%
  gt_theme



print(energy_anova_gt_table)
print(energy_tukey_gt_table)


# Saving tables as PNG files
gtsave(energy_anova_gt_table, filename = here::here("Figures", "anova_temperature_results.png"))
gtsave(energy_tukey_gt_table, filename = here::here("Figures", "tukey_hsd_temperature_results_simplified.png"))

```

## Mesocosm Plots

```{r Plotting the Data, message=FALSE, warning=FALSE}
# Remove rows with missing values
pH.data <- mesocosm.data %>%
  dplyr::select(Temp_Treatment, pH_Treatment, pH) %>%
  na.omit()

# Create the plot with adjusted centrality label arguments
pH_treatment_plot <- pH.data %>% 
  ggbetweenstats(
    data = pH.data,
    x = pH_Treatment,
    y = pH,
    type = "parametric",
    pairwise.display = "significant",
    var.equal = FALSE,  # Welch's t-test
    title = NULL,
    subtitle = NULL,
    xlab = "pH Treatment",
    ylab = TeX("$pH_{T}$ (mol/kg)"),
    results.subtitle = FALSE,  # Don't display statistical results as subtitle
    centrality.point.args = list(
      size = 4,
      stroke = 0,
      color = c("orange", "cyan3")  # Set colors for both points and centrality points
    ),
    centrality.label.args = list(
      size = 2,  # Smaller font size for centrality labels
      nudge_x = -0.2, segment.linetype = 4,
      color = "black"  # Example color setting
    )
  ) +
  scale_y_continuous(limits = c(7.3, 8.3), breaks = seq(7.3, 8.3, by = 0.2), expand = c(0, 0)) +
  geom_signif(comparisons = list(c("Ambient", "Low")), test.args = list(exact = TRUE),
              map_signif_level = TRUE, test = "t.test") + # Add significance annotations
  scale_color_manual(values=c("orange", "cyan3")) + # Set colors for the significance annotations
  common_theme +  # Assuming common_theme is something like this
  theme(
    plot.margin = margin(t = 1, r = 0, b = 1, l = -1, unit = "cm"))

## remove layer corresponding to sample size
pH_treatment_plot <- delete_layers(pH_treatment_plot, "GeomText")

print(pH_treatment_plot)
ggsave(here("Figures", "pH_Treatment_Plot.png"), plot = pH_treatment_plot, width = 4.5, height = 4, dpi = 1300)

# Extract unique Temp_Treatment values
temp_treatment_values <- unique(mesocosm.data$Temp_Treatment)
# Create a data frame for horizontal lines
hline_data <- data.frame(Temp_Treatment = temp_treatment_values)
hline_data$Temp_Treatment <- as.numeric(as.character(hline_data$Temp_Treatment))

# Prepare the data
temp.data <- mesocosm.data %>%
  dplyr::select(Temp_Treatment, pH_Treatment, Temp_C) %>%
  mutate(Interaction = interaction(Temp_Treatment, pH_Treatment, sep = "°C \n"),
         Interaction = factor(Interaction,
         levels = unique(Interaction[order(Temp_Treatment, pH_Treatment)]), ordered = TRUE),
         color = ifelse(pH_Treatment == "Ambient", "orange", "cyan3")) %>% 
  na.omit()


temp_treatment_plot <- ggplot(temp.data, aes(x = Temp_Treatment, y = Temp_C, fill = pH_Treatment)) +  # 'fill' used for boxplot
  
  geom_hline(data = hline_data, aes(yintercept = Temp_Treatment, color = Temp_Treatment), 
             linewidth = 0.4, linetype = "dashed") +  
  stat_boxplot(geom="errorbar", linewidth=0.4, width=0.85)+
  geom_boxplot(outlier.shape = NA, color="white", linewidth = 0.25, width=0.85) + 
  geom_boxplot(outliers = FALSE, alpha = 0.75, linewidth=0.25, width=0.85) +  # Make boxplot semi-transparent to see colors
  labs(title = NULL,
       x = "Temperature Treatment",
       y = "Seawater Temperature (°C)") +
  scale_y_continuous(limits = c(10, 30), breaks = seq(10, 30, by = 4), expand = c(0, 0)) +
  scale_fill_manual(values = c("Ambient" = "orange", "Low" = "cyan3")) +  # Color scale for boxplot fill
  scale_color_gradient(low = "#ffeda0", high = "red3", name = "Temp. Treatment") +  # Color gradient for hline
  common_theme +
  theme(aspect.ratio = 1.4/1.15, 
        legend.position="none",
        margin(t = 0.5, r = -0.5, b = 0, l = -0.5, unit = "cm")
        ) #+
 # coord_flip()  # Flip the coordinates for horizontal boxplot

print(temp_treatment_plot)
ggsave(here("Figures", "Temperature_Treatment_Plot.png"), plot = temp_treatment_plot, width = 4.5, height = 3, dpi = 1300)

temp_treatment_plot <- temp_treatment_plot +
  theme(plot.margin = margin(t = 1, r = 0, b = 0.75, l = 0.15))

pH_treatment_plot <- pH_treatment_plot +
  theme(plot.margin = margin(t = 1, r = 0.15, b = 0.75, l = 0))

combined_temp_pH <- cowplot::plot_grid(temp_treatment_plot, pH_treatment_plot, 
                                       labels = c("(A)", "(B)"),
                                       label_size = 14, label_fontfamily = "serif",
                                       nrow = 1, 
                                       rel_widths = c(4, 3),  rel_heights=c(3, 3))


ggsave(here("Figures", "Combined_Temperature_pH_Plot.png"), plot = combined_temp_pH,
       width = 7, height = 3, dpi = 1300) 


```

```{r}
```




# Thermal Performance Curve Analysis 

## Analyzing Respirometry Data


```{r Clearing Environment, message=FALSE, include=FALSE} 
# Clear the environment
rm(list = ls())
```

# Data Preparation for Respiration Analysis 

```{r For Loop for Reading and Writing Respiration Data, eval=FALSE, include=FALSE}

# Reading in respiration metadata
respo.metadata <- read_csv(here::here("Data", "Experiment_Metadata", "Respirometry_Metadata.csv"))

# Function to read a CSV file, skip the first row, skip the last few rows, and check for issues
read_and_process_csv <- function(filename, path) {
  
  # Determine the number of lines in the file and subtract 4 to skip the last few
  total_lines <- length(readLines(file.path(path, filename)))
  data_length <- total_lines - 4  # Assuming the last 4 lines are not needed
  
  # Read the CSV file, skipping the first row and the last few rows
  data <- read_csv(file.path(path, filename), skip = 1, n_max = data_length, col_names=TRUE, 
                   show_col_types = FALSE, name_repair = "unique_quiet")
  
  # Return the data without the last rows
  return(data)
}

#Set the path to the location of the raw oxygen data files
path.p <- here::here("Data","Respirometry_Data")

#renaming the file names as file.names.full
file.names <- list.files(path = path.p, pattern = "csv$", recursive = TRUE)

#creating data frame to import respiration data into 
respiration.rates <- data.frame(matrix(NA, nrow=length(file.names), ncol=6)) #setting column names
colnames(respiration.rates) <- c("File_ID","Intercept", "umolO2.L.sec","Temp.C", "Salinity", "Pressure") 

for(i in 1:length(file.names)) {
  
#Reading and processing respirometry data
Respiration_Data <- read_and_process_csv(file.names[i], path.p) %>%
    mutate(File_ID=file.names[i]) %>% # Add the file name to the data frame
    dplyr::select(File_ID, Date, Time, Value, Temp, Salinity, Pressure) %>%  # Selecting variables
    unite(Datetime, Date, Time, sep = " ") %>%  # Combine Date and Time into Datetime
    mutate(Datetime = mdy_hms(Datetime)) %>%  # Convert Datetime to POSIXct format
    drop_na()  # Drop rows with NA values

  # Getting the active file name
  Filename <- sub(".csv", "", file.names[i])
  
  # Matching file row to file name 
  Row <- which(respo.metadata$File_ID == file.names[i])
  
  Start_Time <- ymd_hms(respo.metadata$Respirometry_Start_Time[Row])
  Stop_Time <- ymd_hms(respo.metadata$Respirometry_Stop_Time[Row])
  
  # Trimming start and stop times
  Respiration_Data <-  Respiration_Data %>%
    filter(Datetime >= Start_Time & Datetime <= Stop_Time) %>% # filter to start and stop time
    slice(120:n()) %>% # drop the first two minutes of data
    mutate(Sec = 1:n())  # create a new column for every second for the regression
  
  Respiration_Data_Unthinned <- Respiration_Data # saving original data prior to thinning
  
  Respiration_Tibble <- tibble(Time = as.numeric(), Value = as.numeric(),
                               Temp = as.numeric(), Sec = as.numeric(),
                               Salinity = as.numeric(), Pressure = as.numeric())

  Subsample <- respR::subsample(Respiration_Data, n = 15, plot=FALSE)
  Respiration_Tibble<-rbind(Respiration_Tibble, Subsample)
  
# Plotting full data     
full.plot<- ggplot(Respiration_Data_Unthinned, aes(x = Sec, y = Value)) +
    geom_point(color = "lightblue") +
    labs(x = 'Time (seconds)', y = expression(paste(' O'[2],' (',mu,'mol/L)')),
      title = "Original Data")
  
# Plotting thinned data 
thinned.plot <- ggplot(Respiration_Tibble, aes(x = Sec, y = Value))+
    geom_point(color = "lightblue")+
    labs(x = 'Time (seconds)', y = expression(paste(' O'[2],' (',mu,'mol/L)')),
      title = "Thinned Data")

# Defining the alpha value for bootstrapping
N <- nrow(Respiration_Tibble)
alpha <- 0.3  #alpha value for bootstrapping
min_n <- alpha * N

if (min_n < 15) {
  stop("Alpha is too small")
}

# Bootstrapping technique (Olito et al. 2017)
Regs <- rankLocReg(xall=Respiration_Tibble$Sec, yall=Respiration_Tibble$Value, alpha=alpha, method="pc", verbose=TRUE)  

#creates pdf of each individual respiration plot and statistics for each plot
pdf(paste0(here::here("Output","Respo_Output","Thinning_Plots"),"/", Filename ,"thinning.pdf"))
  
plot(Regs) # plot the results of the regs bootstrapping technique
plot(full.plot+thinned.plot) # use patchwork to bring the raw and thinned data together
dev.off()

# fill in all the O2 consumption and rate data
respiration.rates[i,2:3] <- Regs$allRegs[1,c(4,5)] #inserts slope and intercept in the dataframe
respiration.rates[i,1] <- paste0(Filename,".csv") #stores the file name
respiration.rates[i,4] <- mean(Respiration_Tibble$Temp, na.rm=TRUE) #stores mean temperature organisms experienced
respiration.rates[i,5] <- mean(Respiration_Tibble$Salinity, na.rm=TRUE) #stores mean salinity organisms experienced
respiration.rates[i,6] <- mean(Respiration_Tibble$Pressure, na.rm=TRUE) #stores mean pressure organisms experienced

}

#writing out data as a CSV
write_csv(respiration.rates, here("Data", "Thinned_Respirometry_Data", "Respirometry.Data.csv")) #saves to location


```

# Loading Data


```{r, Loading Data, eval=FALSE, message=FALSE}

# Reading in Experiment Data 

# Reading in experimental treatment metadata for the mesocosm 
experiment.metadata <- read_csv(here::here("Data", "Experiment_Metadata","Experiment_Treatment_Metadata.csv"))

# Reading in mesocosm system data and averaging pH and temperature data
mesocosm.treatment.data <- read_csv(here::here("Data", "Mesocosm_Data", "Completed_Mesocosm_Dataset_Carbonate.csv")) %>% 
  filter(Tank_ID != "Sump") %>%
  filter(Date >= "2022-08-21") %>%
  filter(Date != "2022-08-27") %>%
  dplyr::select(Temp_Treatment, pH_Treatment, Temp_C, pH) %>% 
  dplyr::group_by(Temp_Treatment, pH_Treatment) %>%
  dplyr::summarize(Mean_pH=mean(pH, na.rm = TRUE),
                   Mean_Temp=mean(Temp_C, na.rm = TRUE))

# Merging the experimental treatment data 
treatment.info <- left_join(experiment.metadata, mesocosm.treatment.data) 

# Reading in organism data 

# Reading in organism morphometric data 
snail.data <- read_csv(here::here("Data", "Snail_Data", "Tegula_funebralis_Morphometric_Data.csv")) %>% 
  dplyr::select(Snail_ID:Experiment_End_Date)

# Reading in ash free dry weight data and calculating ash free dry weight 
snail.afdw.data <- read_csv(here::here("Data", "Snail_Data","Tegula_funebralis_AFDW.csv"))%>% 
  dplyr::select(Snail_ID, Ash_Free_Dry_Weight)

# Joining experimental treatment metadata and snail data 
experiment.data <- left_join(treatment.info, snail.data) %>% 
  left_join(snail.afdw.data)

# Reading in respiration data 

# Reading in respiration metadata
respo.metadata <- read_csv(here::here("Data", "Experiment_Metadata", "Respirometry_Metadata.csv"))

# Loading in respiration data from the foor loop 
respirometry.data <- read_csv(here("Data", "Thinned_Respirometry_Data", "Respirometry.Data.csv"))

# Merging respiration data with the experimental data 
joined.respo.dataset <- left_join(experiment.data, respo.metadata) %>% 
  left_join(respirometry.data) %>% 
  dplyr::select(-File_ID, -Respirometry_Start_Time, -Respirometry_Stop_Time, -Experiment_Start_Date, -Experiment_End_Date)

#Removing snails that faced mortality during the experiment
filtered.respo.dataset <- joined.respo.dataset %>% 
  filter(Snail_ID != 43,
         Snail_ID != 52, #energetic
         Snail_ID != 36,
         Snail_ID != 72) 
 # mortality (not responsive to forceps)

#load in image icon for plots
image <- readPNG(here::here("Images", "Tegula_funebralis_icon.png"))


#calculating chamber water volume by subtracting organism volume from chamber volume
respo.dataset <- filtered.respo.dataset %>%    
  mutate(Volume_mL = 650-Organism_Volume_mL, #Volume of water in chamber = full chamber volume (650 mL) of water minus organism volume (seawater columns set to 0)
         Volume_L = conv_multiunit(Volume_mL, "mL", "L"), #converting from mL to L (/1000)
         umolO2.sec = umolO2.L.sec*Volume_L) #standardizing to umolO2/sec

# Filtering control respiration rates
respo.control.data <- respo.dataset %>%
  filter(Identity=="Control") %>% 
  group_by(Temp_Treatment, pH_Treatment) %>% #grouping by treatments and control identity
  dplyr::summarize(blank.rate = mean(umolO2.sec, na.rm=TRUE)) #means for blank seawater respiration 

# Joining summarized control respiration data to full respiration dataset 
respo.dataset <- left_join(respo.dataset, respo.control.data)

# Conversionting respiration rates and normalizing to ash free dry weight (grams) 
respo.rates.dataset <- respo.dataset %>% 
  mutate(
    
    # calculating corrected respiration rates
    umolO2.sec = -(umolO2.sec - blank.rate), # subtract the blank rates from the raw rates

    # converting from umolO2/sec to umolO2/hour
    umolO2.hr=conv_resp_unit(umolO2.sec, from="umol_O2 / sec", to="umol_O2 / hr"),
    umolO2.gram.hr = umolO2.hr / Ash_Free_Dry_Weight,
    
    # converting from umolO2/sec to mmolO2/hour
    mmolO2.hr = conv_resp_unit(umolO2.sec, from="umol_O2 / sec", to="mmol_O2 / hr"), 
    mmolO2.gram.hr = mmolO2.hr / Ash_Free_Dry_Weight,
    
    # converting from mmol/hr to molO2/hour
    molO2.hr = mmolO2.hr / 1000,
    molO2.gram.hr = molO2.hr / Ash_Free_Dry_Weight,

    # converting from umolO2/sec to mLO2/hr
    mLO2.hr = conv_resp_unit(umolO2.sec, from="umol_O2 / sec", to="ml_O2 / hr"),
    mLO2.gram.hr = mLO2.hr / Ash_Free_Dry_Weight,
    
    # converting from mLO2/hr to uLO2/hr
    uLO2.hr = mLO2.hr*1000, # converting from mL to uL
    uLO2.gram.hr = uLO2.hr/ Ash_Free_Dry_Weight) %>% 
  
  filter(Identity == "Treatment") 

 as_tibble(respo.rates.dataset)

write_csv(respo.rates.dataset, here("Data", "Thinned_Respirometry_Data", "Respiration.Rates.Dataset.csv"))

#Paine 1971 ~206 uL O2/hr @ 13.5 C ~ 413 uL O2/hr @ 23 C (+ or - 66 uL O2/hr)
```

```{r Examining Respo Rates, warning=FALSE, message=FALSE}

# Creating a discrete color palette for the insect orders
colourCount <- length(unique(respo.rates.dataset$pH_Treatment))
pal.1 <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set1"))(colourCount)

# Scaling figure with orders color-coded
ggplot(respo.rates.dataset, aes(x=log10(Ash_Free_Dry_Weight), y=log10(umolO2.hr), color=pH_Treatment)) + 
  geom_point(aes(col=pH_Treatment), size=1) + 
  scale_color_manual(values=pal.1) +
  stat_smooth(method="lm", se=T)  + 
  common_theme 

pal.1 <- c("cyan3", "orange", "#E41A1C", "#3A85A8", "#629363", "#C4625D", "#FFC81D", "#BF862B", "#EB7AA9", "#999999")
# Scaling figure with orders color-coded
ggplot(respo.rates.dataset, aes(x=log10(Ash_Free_Dry_Weight), y=log10(umolO2.hr), color=as.factor(Temp_Treatment), group=as.factor(pH_Treatment))) + 
  facet_wrap(~Temp_Treatment) +
  geom_point(aes(col=as.factor(Temp_Treatment)), size=1) + 
  scale_color_manual(values=pal.1) +
  stat_smooth(method="lm", se=T) + 
  common_theme 
```


## Joule Rate Calculation Table

```{r}

# Caloric Coefficients Data
coefficients_data <- tibble(
  Substrate = c("Carbs", "Lipid", "Protein", "Average"),
  `J/mg O2` = c(14.77, 13.73, 13.61, 14.10),
  `J/ml O2` = c(21.06, 19.58, 19.41, 20.11),
  `J/mmol O2` = c(481.86, 447.93, 444.01, 460.00)
)

#Calculating Joules and Kilocalories from Respiration Rates using oxyjoulimetric conversions and calorific coefficients
#Joules = Respiration Rate (mmolO2/hr) * Caloric Coefficient (J/mmol O2)
#calorific coefficients used to convert 
#Substrate	J/mg O2	  J/ml O2	  J/mmol O2	     Ref
#Carbs      14.77	      21.06 	  481.86	     Ivlev 1935; Elliot & Davison 1975; Gnaiger 1983 
#Lipid	    13.73	      19.58	    447.93	     Ivlev 1935; Elliot & Davison 1975; Gnaiger 1983
#Protein. 	13.61	      19.41	    444.01	     Ivlev 1935; Elliot & Davison 1975; Gnaiger 1983 #Average. 	14.10	      20.11	    460.00       Ivlev 1935; Elliot & Davison 1975; Gnaiger 1983

# Create the gt table for Caloric Coefficients
coefficients_table <- gt(coefficients_data) %>%
  tab_header(
    title = "Caloric Coefficients for Respiration Rates",
    subtitle = "Oxy-Joulimetric Conversions"
  ) %>% gt_theme %>%
  cols_label(
    Substrate = "Substrate",
    `J/mg O2` = html("J mg<sup>-1</sup> O<sub>2</sub>"),
    `J/ml O2` = html("J ml<sup>-1</sup> O<sub>2</sub>"),
    `J/mmol O2` = html("J mmol<sup>-1</sup> O<sub>2</sub>"))
  

# Print the table to see the results
print(coefficients_table)
gt::gtsave(coefficients_table, here("Figures", "gt_table_caloric_coefficients.png"))
```

# Energetic Expenditure Calcualtion and Data Analysis 

```{r Energetic Analysis, message=FALSE, warning =FALSE}


respo.rates.dataset <- read_csv(here::here("Data", "Thinned_Respirometry_Data", "Respiration.Rates.Dataset.csv"), show_col_types = FALSE) 


joule.rates.dataset <- respo.rates.dataset %>%
  mutate(
    J.gram.hr = mmolO2.gram.hr * 460.00,  # Energy equivalent in J/hr, using the correct constant
    kJ.gram.hr = J.gram.hr / 1000  # Convert Joules per hour to kilojoules per hour
  ) %>%
  dplyr::select(Snail_ID, Temp_Treatment, pH_Treatment, Temp.C, kJ.gram.hr, J.gram.hr) %>%
  mutate(
    Temp_Treatment = as.factor(Temp_Treatment),
    pH_Treatment = as.factor(pH_Treatment)
  )


# Perform a two-way ANOVA
Jhr_model <- lm(log(J.gram.hr) ~ Temp_Treatment * pH_Treatment, data = joule.rates.dataset)
anova_result <- anova(Jhr_model)
#check_model(Jhr_model) # interactive effect is significant thus we dont need to check main effects
# Note: check_model function is typically part of diagnostic steps; ensure it's correctly defined or available in your context

# Inspect the model diagnostic metrics
model.metrics <- augment(Jhr_model) %>%
  dplyr::select(-.hat, -.sigma, -.fitted) # Remove details
head(model.metrics, 3)

#Check for outliers # three outliers none extreme
#joule.rates.dataset %>%
    #group_by(Temp_Treatment, pH_Treatment) %>%
    #identify_outliers(J.gram.hr)

# Assess normality of residuals using shapiro wilk test
energy.shapiro.test <- shapiro_test(model.metrics$.resid)
# homogeneity of variance (not sinificant)
energy.levene.test <- model.metrics %>% levene_test(.resid ~ Temp_Treatment*pH_Treatment)

significance <- joule.rates.dataset %>%
 group_by(Temp_Treatment) %>%
 emmeans_test(J.gram.hr ~ pH_Treatment, p.adjust.method = "tukey")
significance

# Tidy up the ANOVA result into a data frame
anova_df <- tidy(anova_result)

# Convert and format the 'p.value' column to scientific notation
anova_df <- anova_df %>%
  format_p_values() 


anova_df <- anova_df %>% 
  mutate(
    term = gsub("_", " ", term),# Replace underscores with spaces 
    term = tools::toTitleCase(term),  # Capitalize terms
    # Round statistical metrics to two significant figures
    sumsq = signif(sumsq, digits = 2),
    meansq = signif(meansq, digits = 2),
    statistic = signif(statistic, digits = 2)
  ) 

anova_df <- anova_df %>%
  mutate(across(everything(), ~ ifelse(is.na(.), "", .))) %>%
  dplyr::select(term, p.value, statistic, sumsq, meansq, df) 

#print(anova_df)

# Perform a Tukey's HSD test
tukey_result <- TukeyHSD(aov(log(J.gram.hr) ~ Temp_Treatment * pH_Treatment, data = joule.rates.dataset))

tukey_df <- broom::tidy(tukey_result) 

# Filter Tukey results for "Low" vs "Ambient"
tukey_filtered <- tukey_df %>%
    mutate(
        adj.p.value = as.numeric(adj.p.value)
    ) %>%
    filter(grepl("Low", contrast) & grepl("Ambient", contrast)) %>%
    dplyr::select(comparison = contrast, diff = estimate, lwr = conf.low, upr = conf.high, `p.adj` = adj.p.value) %>%
    dplyr::arrange(p.adj) %>%
    mutate(
        NumberLow = as.numeric(str_extract(comparison, "^\\d+")),  # Get number before ':Low'
        NumberAmbient = as.numeric(str_extract(comparison, "\\d+(?=:Ambient$)"))  # Get number before ':Ambient'
    ) %>%
    filter(!is.na(NumberLow) & !is.na(NumberAmbient), NumberLow == NumberAmbient) %>%
    dplyr::select(comparison, diff, lwr, upr, p.adj) %>%
    arrange(comparison)


print(tukey_filtered)

# Create a table for the ANOVA results
anova_table <- anova_df %>%
  gt() %>%
  tab_header(
    title = md("**Two-Way ANOVA Summary for Energetic Expenditure in *Tegula funebralis***"),
    subtitle = md("Analysis of Variance for Temperature and pH Treatments")
  ) %>%
  cols_label(
    term = "Term",
    p.value = "P-Value",
    statistic = "F-Statistic",
    sumsq = "Sum of Squares",
    meansq = "Mean Squares",
    df = "Degrees of Freedom"
  ) %>%
  gt_theme

# Create a table for the Tukey's HSD results
tukey_table <- tukey_filtered %>%
  gt() %>%
  tab_header(
    title = md("**Tukey's HSD Test for Energetic Expenditure in *Tegula funebralis***"),
    subtitle = md("Comparative Analysis of Low vs. Ambient Treatments")
  ) %>%
  cols_label(
    comparison = "Comparison",
    diff = "Difference",
    lwr = "Lower Bound",
    upr = "Upper Bound",
    p.adj = "Adjusted P-Value"
  ) %>%
  gt_theme


# Print the resulting data frames
print(anova_table)
print(tukey_table)

# Save the tables as PNG images
gtsave(anova_table, here("Figures", "gt_table_anova_energy_expenditure.png"))

gtsave(tukey_table, here("Figures", "gt_table_tukey_energy_expenditure.png"))
```


```{r, message= FALSE}

# joule rate summary statistics 
joule.rates.summary <- joule.rates.dataset %>%
  filter(pH_Treatment != "Sump") %>%
  group_by(Temp_Treatment, pH_Treatment) %>%
  summarize(
    Mean_joule_sec = mean(J.gram.hr),
    Median_joule_sec = median(J.gram.hr),
    Min_joule_sec = min(J.gram.hr),
    Max_joule_sec = max(J.gram.hr),
    SD_joule_sec = sd(J.gram.hr),
    SE_joule_sec = sd(J.gram.hr) / sqrt(n()),
    N_joule_sec = n()
  ) 

mean_joule_sec <- joule.rates.summary %>%
  group_by(Temp_Treatment,pH_Treatment) %>%
  dplyr::select(Temp_Treatment, pH_Treatment, Mean_joule_sec) 

# Pivot the data to have Temp_Treatment as rows and pH_Treatment as columns
pivot_mean_joule_sec <- pivot_wider(mean_joule_sec, names_from = pH_Treatment, values_from = Mean_joule_sec)

# Calculate the percent difference
difference_mean_joule_hr <- pivot_mean_joule_sec %>%
  group_by(Temp_Treatment) %>%
  mutate(
    Percent_Difference = (Ambient - Low) / Ambient*100,
    Percent_Difference = signif(Percent_Difference, 2),
    Ambient = signif(Ambient, 2),
    Low = signif(Low, 2)
  ) %>%
  ungroup()


# Assuming difference_mean_joule_table is already defined in your environment
tbl_joule <- gt(difference_mean_joule_hr) %>%
  tab_header(
    title = md("**Energetic Expenditure (Joule g<sup>-1</sup> hr<sup>-1</sup>) in *Tegula funebralis* Statistical Summary**"),
    subtitle = md("Comparative Analysis by Temperature Treatment")
  ) %>%
  cols_label(
    Temp_Treatment = "Temperature Treatment",
    Ambient = "Ambient Energy Expenditure (J/h)",
    Low = "Low Energy Expenditure (J/h)",
    Percent_Difference = "Percent Difference (%)"
  ) %>%  gt_theme
#%>% 
 # gt_plt_bar(column = Percent_Difference, color = "red3", scale_type="percent")

print(tbl_joule)
gt::gtsave(tbl_joule, here("Figures", "gt_table_energy_expenditure.png"))


```


```{r, warning=FALSE, message=FALSE}
# Ensure Temp_Treatment is a factor ordered from 12 to 26
difference_mean_joule_hr$Temp_Treatment <- factor(difference_mean_joule_hr$Temp_Treatment, levels = 12:26)

difference_mean_joule_hr <- difference_mean_joule_hr %>% 
  mutate(fill=ifelse(Percent_Difference >= 0, "#ffeda0", "red3"))


# Create the circular bar plot
p <- ggplot(difference_mean_joule_hr, aes(x = Temp_Treatment, y = Percent_Difference),
            fill=fill) +
  geom_hline(yintercept = 0, color = "black", linetype="dashed", size = 0.5) +
  geom_hline(yintercept = 45, color = "black", linetype="dashed", size = 0.25) +
  geom_segment(data = data.frame(x = unique(difference_mean_joule_hr$Temp_Treatment)), 
               aes(x = x, y = 45, xend = x, yend = -75), color = "black", size = 0.25) +
  geom_bar(stat = "identity", aes(fill = fill), width = 0.85) +
  geom_text(aes(label = paste0(round(Percent_Difference, 1), "%"),
                y = if_else(Percent_Difference >= 0,
                            Percent_Difference + 1, Percent_Difference - 1),
                color = if_else(Percent_Difference >= 0, "black", "white")), 
            position = position_stack(vjust = 0.5), size = 2.5) +
  scale_fill_identity()+
  coord_polar(start = -pi/2.04) +
  scale_y_continuous(breaks = seq(-75, 45, by=15), expand=c(0,1)) +
  scale_color_identity() +
  common_theme+
  theme(
    plot.margin = margin(t = 1, r = 0, b = -9, l = 0),
    panel.background = element_rect(fill = "white", color="white"),
    panel.border = element_blank(),
    # Remove axis ticks and text
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(margin=margin(b=-10)),
    axis.title.y=element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y= element_line(color="grey90", linewidth=0.2),
    # Use gray text for the region names
    axis.text = element_text(color = "gray12", size = 12, family="serif", margin=margin(t=-10)),
    # Move the legend to the bottom
    legend.position = "bottom") +
  labs(title="Temperature Treatment")+
  # Annotate custom scale inside plot
  annotate(
    x = 17, 
    y = 10, 
    label = NA, 
    geom = "text", 
    color = "gray12", 
    family = "serif", size=2, hjust = 0.6, vjust = -0.4
  ) + annotate("text", x = rep(0, 9), y = seq(-75, 45, by=15), 
           label = paste0(seq(-75, 45, by=15), "%"),  # Append percentage sign
             color = "black", size = 3, angle = 0,
           family="serif", hjust = 1.2) 

# Print the plot
#print(p)

ggsave(here("Figures", "circular_bar_plot_energy_expenditure.png"), p, width = 8,height =4.5, dpi = 1300)
```


```{r, warning=FALSE, message=FALSE}
energetic_bar_plot <- ggplot(difference_mean_joule_hr, aes(x = Temp_Treatment, y = Percent_Difference)) +
  geom_col(aes(fill = ifelse(Percent_Difference >= 0, "#ffeda0", "red3")),
           color="black", linewidth=0.2) +  # Conditional fill
  labs(
    x = NULL,
    y = "Energetic Expenditure Difference (%)"
  ) +
  scale_fill_identity() +  # Use the colors specified in the data
  common_theme + 
  scale_y_continuous(breaks = seq(-60, 40, by = 10)) +
  ylim(limits = c(-60, 40)) +  # Set the y-axis limits and breaks
  theme(
  panel.grid.major.x = element_blank(),  # Removes major x gridlines
  panel.grid.minor.x = element_blank(),   # Removes minor x gridlines, if any
  plot.margin = margin(t = 30, r = 10, b = 30, l = 7.5, unit = "pt"),
  x.axis.label = element_text(size=16),
  y.axis.label = element_text(size=16),
  x.axis.text = element_text(size=14),
  y.axis.text = element_text(size=14)
)

#print(energetic_bar_plot)

# Define color palette for pH levels
palette <- c("orange", "cyan3")

boxplot <- ggplot(joule.rates.dataset, aes(x = Temp_Treatment, y = log(J.gram.hr),
                                           color=pH_Treatment, fill = pH_Treatment)) +
 # geom_point(aes(color=pH_Treatment, group=pH_Treatment), position = position_dodge(0.8)) +
  geom_line(aes(group=pH_Treatment), stat = "summary", alpha=0.7,
            fun = mean, linetype = "dashed", position = position_dodge(0.8), linewidth=0.3) +
  stat_boxplot(geom = "errorbar", width = 0.4,
                position = position_dodge(0.8), color= "black", linewidth=0.3)+
  geom_boxplot(outlier.shape = NA, position = position_dodge(0.8), linewidth=0.2,
               width=0.7, color="black") + 
    stat_summary(fun = mean, geom = "point", position = position_dodge(0.8),
               aes(group = pH_Treatment), color="black", size=0.75) +
  stat_compare_means(method = "anova", aes(group = pH_Treatment),
                     label = "p.signif", hide.ns = TRUE, size=4, label.y = 3)+
  stat_compare_means(aes(group = pH_Treatment),
  hide.ns = TRUE, method = "t.test", size=1, label = "p.signif") +
  scale_color_manual(values = palette) +
  scale_fill_manual(values = palette) +
  scale_y_continuous(breaks = seq(1, 4, by = 1), expand = c(0, 0)) +
  labs(x = NULL, 
       y = TeX("$Energetic \\ Expenditure\\ (\\log(J\\ g^{-1}\\ hr^{-1}))$"),
       title = NULL) +
  common_theme +
  theme(
  plot.margin = margin(t = 30, r = 0, b = 30, l = 7.5, unit = "pt"),  # Adjust margin
  x.axis.label = element_text(size=16),
  y.axis.label = element_text(size=16),
  x.axis.text = element_text(size=14),
  y.axis.text = element_text(size=14)
)

#print(boxplot)

combined_energetics <- cowplot::plot_grid(boxplot, energetic_bar_plot, labels = c("(A)", "(B)"),
  label_size = 14,  # Adjust label size
  label_fontfamily = "serif",  # Set label font family to serif
  align = 'v',  # Ensure vertical alignment if needed
  axis = 'lr',  # Reduce the gap by aligning top and bottom
  hjust = -0.5, 
  nrow = 1, rel_widths = c(4.5, 2.5))

# Add a common x-axis label using ggdraw() and draw_label()
final_plot <- ggdraw() +
  draw_plot(combined_energetics) +
  draw_label("Temperature Treatment", x = 0.5, y = 0.05, hjust = 0.5, fontfamily = "serif", size=12) + 
  theme(
  plot.margin = margin(t = 10, r = 10, b = 0, l = 7.5, unit = "pt")  # Adjust margin
)

# Print the final plot
print(final_plot)

ggsave(final_plot, filename = here("Figures", "combined_energetics_plot.png"), height = 6, width = 8, dpi = 1300)


```

# Thermal Performance Curve Analysis 


```{r, Data Preparation}

ylab = expression(mu*mol~O[2]~g^-1~hr^-1)
xlab = expression(Temperature~plain("(°C)"))

#load in the data set and select for temperature, rate, and pH treatment
respo.rates.tpc <- respo.rates.dataset %>% 
  mutate(rate=umolO2.gram.hr, temp=Temp.C) %>%
  dplyr::select(Temp_Treatment, pH_Treatment, temp, rate) %>% 
  na.omit(umolO2.gram.hr)

# Create a single ggplot graph with both curves
respo.rates.plot <- ggplot(respo.rates.tpc, aes(Temp_Treatment, rate, color =pH_Treatment)) +
  geom_point() +
  theme_bw() +
  common_theme +
  labs(
    x = xlab,
    y = ylab,
    title = 'Respiration Rates Across Temperatures'
  ) +
  scale_x_continuous(breaks = seq(12, 26, by = 2)) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"))

print(respo.rates.plot)

```
# Defining a theme for table outputs and plotting 

```{r}


gt_theme <- function(data,...) {
  data %>%
  opt_table_font(
    font = "serif") %>%
    fmt_number(
    columns = everything(),
    decimals = 2) %>% 
  tab_style(
      style = list(cell_text(align = "center", font = "serif",
                             size = 12, color = "black", weight=250),
      cell_borders(
        side = "bottom", color = "black", weight = px(1))),
      locations = cells_body(
        columns = everything(), rows = nrow(data$`_data`))
    ) %>%
  tab_style(
    style = list(cell_text(align = "left", font = "serif",
                           size = 12, weight=500, color = "black"),
    cell_fill(color = "grey80", alpha = 0),
    cell_borders(
        side = "right", 
        color = "black",
        weight = px(0.5)
        )),
    locations = cells_stub()
  )  %>% 
  tab_style(
    style=list(cell_text(align = "center", font = "serif", weight="bolder",
                      size = 14, color = "black"), 
        cell_fill(color = "grey50", alpha = 0.01),
        cell_borders(
        sides = c("top", "bottom"), 
        color = "black",
        weight = px(2)
        )),
    locations = cells_title(groups = "title")
  ) %>%
  tab_style(
    style=list(cell_text(align = "center", font = "serif",
                         weight = "bold", size = 12, color = "black"), 
        cell_fill(color = "grey50", alpha = 0.01),
        cell_borders(
        sides = c("top", "bottom"), 
        color = "black",
        weight = px(1)
        )),
    locations = cells_row_groups()
  )  %>% 
    tab_style(
    style = cell_text(align = "center", font = "serif", weight="bold", size = 12, color = "black"),
    locations = cells_column_labels(columns = everything()) 
  ) %>%
  tab_style(
    style = cell_text(align = "center", font = "serif", size = 12, color = "black"),
    locations = cells_body()
  ) %>% 
  tab_options(
    table.width = pct(50),
    table.border.top.width = px(1),
    table.border.top.color = "black",
    table.border.bottom.color = "black",
    table.border.bottom.width = px(1),
    table_body.border.bottom.width = px(1),
    table_body.border.bottom.color = "black",
    table_body.border.top.width = px(1),
    table_body.border.top.color = "black",
    table_body.hlines.width = px(0.5),
    table_body.hlines.color = "grey90",
    column_labels.background.color = "white",
    column_labels.border.top.width = px(1),
    column_labels.border.top.color = "black",
    column_labels.border.bottom.width = px(1),
    column_labels.border.bottom.color = "black",
    row_group.border.top.width = px(1.25),
    row_group.border.top.color = "black",
    row_group.border.bottom.width = px(1.25),
    row_group.border.bottom.color = "black",
    source_notes.font.size = 12,
    table.font.size = 12,
    heading.title.font.size = 14,
    heading.subtitle.font.size = 12,
    heading.align = "center",
    heading.padding = px(10),
    row_group.padding = px(5),
    data_row.padding = px(4),
    ...
  ) 
}

```


```{r Model Selection and Fit}

multi.respo.rates.tpc <- respo.rates.tpc %>% 
  dplyr::select(pH_Treatment, temp, rate) 

# Load in data and filter to keep just a single curve (low pH)
low.pH <- filter(respo.rates.tpc, pH_Treatment == 'Low')

# Load in data and filter to keep just a single curve (high pH)
high.pH <- filter(respo.rates.tpc, pH_Treatment == 'Ambient')

# fit every model formulation in rTPC
model_selection_fits <- nest(multi.respo.rates.tpc, data = c(temp, rate)) %>% 
   mutate(beta = purrr::map(data, ~nls_multstart(rate~beta_2012(temp = temp, a, b, c, d, e),
                        data = .x,
                        iter = c(5,5,5,5,5),
                        start_lower = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'beta_2012') - 10,
                        start_upper = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'beta_2012') + 10,
                        lower = rTPC::get_lower_lims(.x$temp, .x$rate, model_name = 'beta_2012'),
                        upper = rTPC::get_upper_lims(.x$temp, .x$rate, model_name = 'beta_2012'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
          boatman = purrr::map(data, ~nls_multstart(rate~boatman_2017(temp = temp, rmax, tmin, tmax, a,b),
                        data = .x,
                        iter = c(4,4,4,4,4),
                        start_lower = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'boatman_2017') - 10,
                        start_upper = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'boatman_2017') + 10,
                        lower = rTPC::get_lower_lims(.x$temp, .x$rate, model_name = 'boatman_2017'),
                        upper = rTPC::get_upper_lims(.x$temp, .x$rate, model_name = 'boatman_2017'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
         gaussian = purrr::map(data, ~nls_multstart(rate~gaussian_1987(temp = temp, rmax, topt, a),
                        data = .x,
                        iter = c(4,4,4),
                        start_lower = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'gaussian_1987') - 10,
                        start_upper = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'gaussian_1987') + 10,
                        lower = rTPC::get_lower_lims(.x$temp, .x$rate, model_name = 'gaussian_1987'),
                        upper = rTPC::get_upper_lims(.x$temp, .x$rate, model_name = 'gaussian_1987'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
         sharpeschoolfull = purrr::map(data, ~nls_multstart(rate~sharpeschoolfull_1981(temp = temp, r_tref,e,el,tl,eh,th, tref = 15),
                        data = .x,
                        iter = c(4,4,4,4,4,4),
                        start_lower = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolfull_1981') - 10,
                        start_upper = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolfull_1981') + 10,
                        lower = get_lower_lims(.x$temp, .x$rate, model_name = 'sharpeschoolfull_1981'),
                        upper = get_upper_lims(.x$temp, .x$rate, model_name = 'sharpeschoolfull_1981'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
         sharpeschoolhigh = purrr::map(data, ~nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = .x,
                        iter = c(4,4,4,4),
                        start_lower = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') - 10,
                        start_upper = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') + 10,
                        lower = rTPC::get_lower_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = rTPC::get_upper_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
         weibull = purrr::map(data, ~nls_multstart(rate~weibull_1995(temp = temp, a,topt,b,c),
                        data = .x,
                        iter = c(4,4,4,4),
                        start_lower = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'weibull_1995') - 10,
                        start_upper = rTPC::get_start_vals(.x$temp, .x$rate, model_name = 'weibull_1995') + 10,
                        lower = rTPC::get_lower_lims(.x$temp, .x$rate, model_name = 'weibull_1995'),
                        upper = rTPC::get_upper_lims(.x$temp, .x$rate, model_name = 'weibull_1995'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)))

#glimpse(dplyr::select(model_selection_fits, 1:8))

# stack models
model_stack <- dplyr::select(model_selection_fits, -data) %>%
  pivot_longer(., names_to = 'model_name', values_to = 'fit', boatman:weibull)

# get parameters using tidy
params <- model_stack %>%
  mutate(., est = purrr::map(fit, tidy)) %>%
  dplyr::select(-fit) %>%
  unnest(est)

# get predictions using augment
newdata <- tibble(temp = seq(min(respo.rates.tpc$temp), max(respo.rates.tpc$temp), length.out = 100))
model_preds <- model_stack %>%
  mutate(., preds = purrr::map(fit, augment, newdata = newdata)) %>%
  dplyr::select(-fit) %>%
  unnest(preds)

# seperating the curves for graphing seperate
high_pH <- filter(respo.rates.tpc, pH_Treatment == "Ambient") 
high_pH_model_preds <- filter(model_preds, pH_Treatment == "Ambient")
low_pH <- filter(respo.rates.tpc, pH_Treatment == "Low") 
low_pH_model_preds <- filter(model_preds, pH_Treatment == "Low")

# take a random point from each model for labelling
high_pH_model_labs <- filter(high_pH_model_preds, temp < 24) %>%
  group_by(., model_name) %>%
  sample_n(., 1) %>%
  ungroup()

# take a random point from each model for labelling
low_pH_model_labs <- filter(low_pH_model_preds, temp < 24) %>%
  group_by(., model_name) %>%
  sample_n(., 1) %>%
  ungroup()


# plot
wrapped.model.fits <- ggplot(model_preds, aes(temp, rate, color = pH_Treatment)) +
  geom_point(aes(Temp_Treatment, rate), respo.rates.tpc) +
  geom_line(aes(temp, .fitted)) +
  facet_wrap(~model_name, scales = 'free', ncol = 5) +
  common_theme +
  scale_x_continuous(breaks = seq(12, 26, by = 2)) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), 
                     name = "Treatment") +
  labs(x = xlab,
       y = ylab,
       title = 'Thermal Performance Curve Model Fits') +
  geom_hline(aes(yintercept = 0), linetype = 2)

# multiple models low pH plot
low_pH_model_preds_plot <- ggplot(low_pH_model_preds, aes(temp, .fitted)) +
  geom_point(aes(temp, rate), low_pH) +
  geom_line(aes(col = model_name)) +
  geom_label_repel(aes(temp, .fitted, label = model_name, col = model_name), fill = 'white', nudge_x=-1, nudge_y = 15, segment.size = 0.5, size=2.5, family = "serif",
                   segment.colour = 'black', low_pH_model_labs) +
  common_theme +
  theme(plot.subtitle = element_text(hjust = 0.5),
        plot.margin = margin(t = 10, r = 10, b = 10, l = 10, unit = "pt")) +
  scale_x_continuous(breaks = seq(12, 26, by = 2)) +
  labs(x = xlab,
       y = ylab,
       title = 'Thermal Performance Curve Model Fits',
       subtitle='Low pH') +
  geom_hline(aes(yintercept = 0), linetype = 2) +
  scale_color_brewer(type = 'qual', palette = "Set1")

# multiple models high pH plot
high_pH_model_preds_plot <- ggplot(high_pH_model_preds, aes(temp, .fitted)) +
  geom_point(aes(temp, rate), high_pH) +
  geom_line(aes(col = model_name)) +
  geom_label_repel(aes(temp, .fitted, label = model_name, col = model_name), fill = 'white', nudge_x=-1, nudge_y = 15, segment.size = 0.5, size=2.5, family = "serif",
                   segment.colour = 'black', high_pH_model_labs) +
  common_theme +
  theme(plot.subtitle = element_text(hjust = 0.5),
        plot.margin = margin(t = 0, r = 10, b = 10, l = 10, unit = "pt")
        ) +
  scale_x_continuous(breaks = seq(12, 26, by = 2)) +
  labs(x = xlab,
       y = ylab,
       title =  NULL,
       subtitle='Ambient pH') +
  geom_hline(aes(yintercept = 0), linetype = 2) +
  scale_color_brewer(type = 'qual', palette = "Set1")

# Combine plots vertically
combined_model_fits <- low_pH_model_preds_plot / high_pH_model_preds_plot
combined_model_fits
wrapped.model.fits

ggsave(here::here("Figures", "multi_combined_model_fits.png"), combined_model_fits, width = 5, height = 6)
ggsave(here::here("Figures", "wrapped_model_fits.png"), wrapped.model.fits, width = 10, height = 4)
```

# Thermal Performance Curve Model Selection and Comparison

```{r Model Selection and Comparison, message=FALSE, warning=FALSE}

# Calculate AICc and create model_aic
model_aic <- model_stack %>%
  mutate(info = purrr::map(fit, glance),
         AICc =  purrr::map_dbl(fit, MuMIn::AICc)) %>%
  unnest(info) %>%
  dplyr::select(Treatment = pH_Treatment, model_name, sigma, AIC, AICc, BIC, df.residual)

# Title case the model names
model_aic$model_name <- tools::toTitleCase(model_aic$model_name)
model_aic$model_name <- gsub("Sharpeschoolfull", "Sharpe-Schoolfield (Full)", model_aic$model_name)
model_aic$model_name <- gsub("Sharpeschoolhigh", "Sharpe-Schoolfield (High)", model_aic$model_name)

# Write AIC values to CSV file
write.csv(model_aic, "model_aics.csv", row.names = FALSE)

# Find the best model across both pH_Treatment levels
best_model <- model_aic %>%
  group_by(Treatment) %>% 
  filter(AICc == min(AICc)) %>%
  pull(model_name)

# Print the best model
print(best_model)

# Find the best model for low pH
low_pH_best_model <- model_aic %>%
  filter(Treatment == "Low") %>% 
  filter(AICc == min(AICc)) %>%
  pull(model_name) 

# Find the best model for high pH
high_pH_best_model <- model_aic %>%
  filter(Treatment == "Ambient") %>% 
  filter(AICc == min(AICc)) %>%
  pull(model_name) 

# Print the best models
print(paste("Best Low pH Model:", low_pH_best_model))
print(paste("Best High pH Model:", high_pH_best_model))

model_aic <- model_aic %>%
  mutate(across(where(is.numeric), round, 2)) %>% 
  mutate(pH_Treatment=Treatment) %>% 
  mutate(pH_Treatment=ifelse(pH_Treatment=="Low", "Low pH Treatment", "Ambient pH Treatment"))

tbl_aic <- model_aic %>% 
  dplyr::select(-Treatment)

# Display model_aic as a table with highlighted rows for best models
tbl.aic <- tbl_aic %>%
  gt(rowname_col = "model_name", groupname_col = "pH_Treatment") %>%
  tab_header(title = md("**Thermal Performance Model Fit Statistical Summaries**")) %>%
  gt_highlight_rows(rows = which(model_aic$model_name %in%
                                 low_pH_best_model & model_aic$pH_Treatment == "Low pH Treatment"),
                                 font_weight = "normal", fill="cyan3") %>%
  gt_highlight_rows(rows = which(model_aic$model_name %in%
                                 high_pH_best_model & model_aic$pH_Treatment == "Ambient pH Treatment"),
                                 font_weight = "normal", fill="orange") %>%
  cols_label(
    model_name = "Model",
    AIC = "AIC",
    AICc = "AICc",
    BIC = "BICc",
    sigma = "Sigma",
    df.residual = "df"
  ) %>% gt_theme 


print(tbl.aic)

# Save the table as a PNG image
gtsave(tbl.aic, here::here("Figures", "model_fits_aic.png"))

# Title case the model names for plotting
low_pH_model_preds$model_name <- tools::toTitleCase(low_pH_model_preds$model_name)
low_pH_model_preds$model_name <- gsub("Sharpeschoolfull", "Sharpe-Schoolfield (Full)", low_pH_model_preds$model_name)
low_pH_model_preds$model_name <- gsub("Sharpeschoolhigh", "Sharpe-Schoolfield (High)", low_pH_model_preds$model_name)
high_pH_model_preds$model_name <- tools::toTitleCase(high_pH_model_preds$model_name)
high_pH_model_preds$model_name <- gsub("Sharpeschoolfull", "Sharpe-Schoolfield (Full)", high_pH_model_preds$model_name)
high_pH_model_preds$model_name <- gsub("Sharpeschoolhigh", "Sharpe-Schoolfield (High)", high_pH_model_preds$model_name)

# Plot for low pH
low_pH_model_preds_plot <- ggplot(low_pH_model_preds, aes(temp, .fitted)) +
  geom_point(aes(temp, rate), data = low_pH, size=0.75) +  # Use data = low_pH
  geom_line(aes(group = model_name), col = 'grey50', alpha = 0.5) +
  geom_line(data = filter(low_pH_model_preds, model_name == low_pH_best_model), col = "cyan3") +
  geom_label_repel(aes(temp, .fitted, label = model_name), fill = 'white', segment.size = 0.5,
                   segment.colour = 'black', nudge_x=-1, nudge_y = 15, size=2.5,
                   family = "serif", 
                   data = filter(low_pH_model_labs, model_name == low_pH_best_model),
                   col = "cyan3") +
  common_theme +
    theme(plot.subtitle = element_text(hjust = 0.5),
        plot.margin = margin(t = 10, r = 20, b = 0, l = 10, unit = "pt")
        ) +
  scale_x_continuous(breaks = seq(12, 26, by = 2)) +
  labs(x = xlab,
       y = ylab,
       title = NULL, 
       subtitle='Low pH Treatment') +
  geom_hline(aes(yintercept = 0), linetype = 2)

# Plot for high pH
high_pH_model_preds_plot <- ggplot(high_pH_model_preds, aes(temp, .fitted)) +
  geom_point(aes(temp, rate), data = high_pH, size=0.75) +  # Use data = high_pH
  geom_line(aes(group = model_name), col = 'grey50', alpha = 1) +
  geom_line(data = filter(high_pH_model_preds, model_name == high_pH_best_model), col = "orange") +
  geom_label_repel(aes(temp, .fitted, label = model_name), fill = 'white', segment.size = 0.5,
                   segment.colour = 'black', nudge_x=-1, nudge_y = 15, size=2.5,
                   family = "serif",
                   data = filter(high_pH_model_labs, model_name == high_pH_best_model),
                   col = "orange") +
  common_theme +
    theme(plot.subtitle = element_text(hjust = 0.5),
        plot.margin = margin(t = 10, r = 20, b = 10, l = 10, unit = "pt")
        ) +
  theme(plot.subtitle = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks = seq(12, 26, by = 2)) +
  labs(x = xlab,
       y = ylab,
       title =  NULL,
       subtitle='Ambient pH Treatment') +
  geom_hline(aes(yintercept = 0), linetype = 2) 

# Combine plots vertically
combined_model_fits <- low_pH_model_preds_plot / high_pH_model_preds_plot
combined_model_fits

# Save combined plots to "Figures" folder using here
ggsave(here::here("Figures", "combined_model_fits.png"), combined_model_fits, width = 4, height = 5)
```

Choose the Sharpe Schoolfield model(high) because it had the lowest AIC values for 7.7 and 8.0 pH, collectively and was a biological model used for ectotherms that fit the curve correctly. 

# Fitting the Sharpe-Schoolfield Model to Respiration Rates Across Temperature

```{r, message=FALSE}
# Sharpe-Schoolfield Thermal Performance Curve


#load in the data set and select for temperature, rate, and pH treatment
respo.rates.tpc <- respo.rates.dataset %>% 
  mutate(rate=umolO2.gram.hr, temp=Temp.C) %>%
  dplyr::select(Temp_Treatment, pH_Treatment, temp, rate) 

# keeping just a single curve
low_pH <- filter(respo.rates.tpc, pH_Treatment == 'Low') %>% 
  dplyr::select(-Temp_Treatment)
high_pH <- filter(respo.rates.tpc, pH_Treatment == 'Ambient') %>% 
  dplyr::select(-Temp_Treatment)

# Fit the Sharpe-Schoolfield model for low pH
sharpe_schoolfield_model_low <- nest(low_pH, data = c(temp, rate)) %>%
  mutate(sharpeschoolhigh = purrr::map(data, ~nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = .x,
                        iter = c(4,4,4,4),
                        start_lower = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') - 10,
                        start_upper = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') + 10,
                        lower = get_lower_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
         # create new temperature data
         low_pH_new_data = purrr::map(data, ~tibble(temp = seq(min(.x$temp), max(.x$temp), length.out = 100))),
         # predict over that data,
         low_pH_preds =  purrr::map2(sharpeschoolhigh, low_pH_new_data, ~augment(.x, newdata = .y)))

# unnest predictions
low_pH_preds <- dplyr::select(sharpe_schoolfield_model_low, low_pH_preds)  %>% unnest(low_pH_preds) %>% 
  mutate(pH_Treatment="Low")

# Fit the Sharpe-Schoolfield model for high pH
sharpe_schoolfield_model_high <- nest(high_pH, data = c(temp, rate)) %>%
  mutate(sharpeschoolhigh = purrr::map(data, ~nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = .x,
                        iter = c(4,4,4,4),
                        start_lower = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') - 10,
                        start_upper = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') + 10,
                        lower = get_lower_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
         # create new temperature data
         high_pH_new_data = purrr::map(data, ~tibble(temp = seq(min(.x$temp), max(.x$temp), length.out = 100))),
         # predict over that data,
         high_pH_preds =  purrr::map2(sharpeschoolhigh, high_pH_new_data, ~augment(.x, newdata = .y)))

# unnest predictions
high_pH_preds <- dplyr::select(sharpe_schoolfield_model_high, high_pH_preds) %>% unnest(high_pH_preds) %>% 
  mutate(pH_Treatment="Ambient")

#Joining the data together for plotting 
TPC_preds <- full_join(low_pH_preds, high_pH_preds)


# plotting TPC for Sharpe-Schoolfield (high activation) model 
ggplot() +
  geom_line(aes(temp, .fitted, group=pH_Treatment, color=pH_Treatment), TPC_preds) +
  geom_point(aes(temp, rate, group=pH_Treatment, color=pH_Treatment, fill=pH_Treatment), respo.rates.tpc, size = 1.5, shape = 21, alpha=0.75) +
  facet_wrap(~pH_Treatment) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  scale_fill_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  common_theme +
  labs(x = xlab,
       y = ylab) + 
  scale_y_continuous(breaks = seq(0, 125, 25), limits=c(0,110)) +
  scale_x_continuous(breaks = seq(12, 26, 2), limits=c(12,26.5), position = "bottom") +
  geom_hline(yintercept = 0, linetype = 2)

```


# Bootstrapping the Sharpe-Schoolfield Model to Respiration Rates Across Temperature

```{r, message=FALSE, warning=FALSE}
# Fit the Sharpe-Schoolfield model for high pH using nmls LM prior to bootstrap
low_pH_fit_nlsLM <- minpack.lm::nlsLM(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = low_pH,
                        start = coef(sharpe_schoolfield_model_low$sharpeschoolhigh[[1]]),
                        lower = get_lower_lims(low_pH$temp, low_pH$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(low_pH$temp, low_pH$rate, model_name = 'sharpeschoolhigh_1981'),
                        weights = rep(1, times = nrow(low_pH)), 
                        na.action=na.exclude,
                        control = nls.control(maxiter = 1000, tol = 1e-6, minFactor = 1e-8, warnOnly = TRUE))

# Fit the Sharpe-Schoolfield model for high pH using nmls LM prior to bootstrap
high_pH_fit_nlsLM <- minpack.lm::nlsLM(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = high_pH,
                        start = coef(sharpe_schoolfield_model_high$sharpeschoolhigh[[1]]),
                        lower = get_lower_lims(high_pH$temp, high_pH$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(high_pH$temp, high_pH$rate, model_name = 'sharpeschoolhigh_1981'),
                        weights = rep(1, times = nrow(high_pH)),
                        na.action=na.exclude,
                        control = nls.control(maxiter = 1000, tol = 1e-6, minFactor = 1e-8, warnOnly = TRUE))

# bootstrap technique case versus residual bootstrapping 
# using residual resampling due to decreased standard error 

##  bootstrap using case resampling
low_pH_boot_case <- Boot(low_pH_fit_nlsLM, method = 'case', R=999)
high_pH_boot_case <- Boot(high_pH_fit_nlsLM, method = 'case', R=999)

## bootstrapping using residual resampling 
low_pH_boot_residual <- Boot(low_pH_fit_nlsLM, method = 'residual', R=999) 
high_pH_boot_residual <- Boot(high_pH_fit_nlsLM, method = 'residual', R=999) 

 # choose bootstrapping through residual due to lower standard error
low_pH_boot_residual_preds <- low_pH_boot_residual$t %>%
  as.data.frame() %>%
  drop_na() %>%
  mutate(iter = 1:n()) %>%
  group_by_all() %>%
  do(data.frame(temp = seq(min(low_pH$temp), max(low_pH$temp), length.out = 100))) %>%
  ungroup() %>%
  mutate(pred = sharpeschoolhigh_1981(temp, r_tref, e, eh, th, tref = 15)) %>% 
  mutate(pH_Treatment="Low")

# predict over new data
high_pH_boot_residual_preds <- high_pH_boot_residual$t %>%
  as.data.frame() %>%
  drop_na() %>%
  mutate(iter = 1:n()) %>%
  group_by_all() %>%
  do(data.frame(temp = seq(min(high_pH$temp), max(high_pH$temp), length.out = 100))) %>%
  ungroup() %>%
  mutate(pred = sharpeschoolhigh_1981(temp, r_tref, e, eh, th, tref = 15)) %>% 
  mutate(pH_Treatment="Ambient")

# calculate bootstrapped confidence intervals
low_pH_boot_residual_CI_preds <- group_by(low_pH_boot_residual_preds, temp) %>%
  summarise(conf_lower = quantile(pred, 0.025),
            conf_upper = quantile(pred, 0.975),
            .groups = 'drop') %>% 
  mutate(pH_Treatment = "Low")

# calculate bootstrapped confidence intervals
high_pH_boot_residual_CI_preds <- group_by(high_pH_boot_residual_preds, temp) %>%
  summarise(conf_lower = quantile(pred, 0.025),
            conf_upper = quantile(pred, 0.975),
            .groups = 'drop') %>% 
  mutate(pH_Treatment = "Ambient")


TPC_boot_residual_preds <- full_join(low_pH_boot_residual_preds, high_pH_boot_residual_preds)
TPC_boot_residual_CI_preds <- full_join(low_pH_boot_residual_CI_preds, high_pH_boot_residual_CI_preds)

# Plotting the Sharpe-Schoolfield Model (Confidence Intervals and Model Predictions)
prediction_plots <- ggplot() +
  geom_point(aes(temp, rate, group=pH_Treatment, color=pH_Treatment), respo.rates.tpc, size = 1.1) +
  geom_line(aes(temp, pred, group = iter, color=pH_Treatment), TPC_boot_residual_preds, linewidth=0.5, alpha = 0.0095) +
  geom_line(aes(temp, .fitted, group=pH_Treatment, color=pH_Treatment), TPC_preds, linewidth=1) +
  facet_wrap(~pH_Treatment) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), name = "pH Treatment") +
  common_theme +
  theme(
    strip.text.x = element_blank(),  # This will remove the facet labels
    legend.position = "top",
    legend.direction = "horizontal",
    legend.text = element_text(size = 12)
  ) +
  labs(x = xlab, y = ylab) + 
  scale_x_continuous(breaks = seq(12, 26, 2), expand = c(0, 0)) +
  scale_y_continuous(breaks = seq(0, 120, 30), limits = c(0, 120), expand = c(0, 0)) +
  geom_hline(yintercept = 0, linetype = 2) 

#print(prediction_plots)

# Assuming 'image' is your initial image path or object
original_image <- image_read(here::here("Images", "Tegula_funebralis_icon.png"))  # Adjust path as needed

# Colorize images with magick
image_ambient <- image_colorize(original_image,  color = "orange", opacity = 0.25)
image_low <- image_colorize(original_image, color = "cyan3", opacity = 0.25)
image_ambient <- image_modulate(image_ambient, brightness = 140)
image_low <- image_modulate(image_low, brightness = 140)


# Write images to files
image_write(image_ambient, "ambient_snail.png", quality=20, format = "png")
image_write(image_low, "low_snail.png", quality=20, format = "png")

# Add a column to your data frame for the image file path based on pH Treatment
respo.rates.tpc$image_path <- ifelse(respo.rates.tpc$pH_Treatment == "Low", "low_snail.png", "ambient_snail.png")
# Example of preparing data for geom_image
respo.rates.tpc$image_path <- ifelse(respo.rates.tpc$pH_Treatment == "Low", "low_snail.png", "ambient_snail.png")
respo.rates.tpc$x <- 13  # Example fixed position, adjust based on your data/needs
respo.rates.tpc$y <- 93  # Example fixed position, adjust based on your data/needs

respo.rates.tpc <- respo.rates.tpc %>% 
  mutate(pH_Treatment = case_when(pH_Treatment == "Low" ~ "pH 7.7", pH_Treatment == "Ambient" ~ "pH 7.9")) %>%
  mutate(pH_Treatment = factor(pH_Treatment, levels = c("pH 7.9", "pH 7.7")))

TPC_boot_residual_CI_preds <- TPC_boot_residual_CI_preds %>% 
  mutate(pH_Treatment = ifelse(pH_Treatment == "Low", "pH 7.7", "pH 7.9"))%>%
  mutate(pH_Treatment = factor(pH_Treatment, levels = c("pH 7.9", "pH 7.7")))
TPC_preds <- TPC_preds %>%
  mutate(pH_Treatment = ifelse(pH_Treatment == "Low", "pH 7.7", "pH 7.9"))%>%
  mutate(pH_Treatment = factor(pH_Treatment, levels = c("pH 7.9", "pH 7.7")))


CI_plots <- ggplot(data = respo.rates.tpc) +
  geom_point(aes(x= temp, y=rate, color = pH_Treatment), size = 1.5) +
  geom_ribbon(aes(x= temp, ymin = conf_lower, ymax = conf_upper, fill = pH_Treatment), data = TPC_boot_residual_CI_preds, alpha = 0.2) +
  geom_line(aes(x=temp, y = .fitted, color = pH_Treatment), data = TPC_preds, size=1) +
  geom_line(aes(x=temp, y = conf_lower, color = pH_Treatment), data = TPC_boot_residual_CI_preds, linetype = "dashed", size = 0.5) +
  geom_line(aes(x=temp, y = conf_upper, color = pH_Treatment), data = TPC_boot_residual_CI_preds, linetype = "dashed", size = 0.5) +
  facet_wrap(~pH_Treatment) +
  scale_fill_manual(values = c("pH 7.7" = "cyan3", "pH 7.9" = "orange"), name = "pH Treatment") +
  scale_color_manual(values = c("pH 7.7" = "cyan3", "pH 7.9" = "orange"), name = "pH Treatment") +
  common_theme +
  theme(strip.text.x = element_blank(), legend.position = "none") +
  labs(x = xlab, y = ylab) +  # Ensure these labels are correctly defined
  scale_x_continuous(breaks = seq(12, 26, 2), expand = c(0.05, 0)) +
  scale_y_continuous(breaks = seq(0, 100, 20), expand = c(0, 2)) +
  #geom_hline(yintercept = 0, linetype = 2) +
geom_label(aes(x = 13, y = 85, label = pH_Treatment,
               family="serif", color=pH_Treatment),  size = 4,
                     label.r=unit(0, "cm"), fill = NA, label.size = NA)+  # Positioning text 
  geom_image(aes(x=x, y=y, image = image_path, color=pH_Treatment, alpha=0.2), size = 0.15) +
  theme(
    plot.margin = margin(10, 10, 10, 10),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    axis.title.y= element_text(size=16), margin = margin(t = 0, r = 5, b = 0, l = 0),
    axis.title.x= element_text(size=16), margin = margin(t = 0, r = 10, b = 0, l = 0),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray90", size = 0.25),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.background = element_rect(fill = "white", color = "white")  # Adjust if needed
  ) 

#print(CI_plots)

# Save the plots as a PNG file
ggsave(here::here("Figures", "TPC_CI_plot.png"), CI_plots, width = 8, height = 5, units = "in")

```

## Exporting Statistical Summary of the sharpe schoolfield Model 

```{r, warning =FALSE, message=FALSE}


process_coefficients <- function(data, pH_label) {
  tidy(data) %>%
    mutate(
      pH_condition = pH_label,
      term = case_when(
        term == "r_tref" ~ "R_Tref",
        term == "e" ~ "E_a",  # Using html() to ensure rendering
        term == "eh" ~ "E_h",
        term == "th" ~ "T_h",
        TRUE ~ term
      ),
      estimate = signif(estimate, digits = 2)  # Ensure estimates are rounded
    )
}

# Adjust bootstrapping results, including bias and std.error directly
process_bootstrap <- function(data, pH_label) {
  tidy(data) %>%
    mutate(
      pH_condition = pH_label,
      term = case_when(
        term == "r_tref" ~ "R_Tref",
        term == "e" ~ "E_a",  # Using html() to ensure rendering
        term == "eh" ~ "E_h",
        term == "th" ~ "T_h",
        TRUE ~ term
      ),
      boot.std.error = std.error,
      bias = bias
    )
}

format_p_values <- function(data) {
  data %>%
    mutate(
      p.value = case_when(
        p.value < 0.001 ~ "<0.001 ***",
        p.value < 0.01  ~ "<0.01 **",
        p.value < 0.05  ~ "<0.05 *",
        is.na(p.value)  ~ "",
        TRUE            ~ sprintf("%.2f", p.value)  # Use sprintf for precise formatting
      )
    )
}


# Process data
low_pH_coefficients <- process_coefficients(low_pH_fit_nlsLM, "Low pH Treatment")
high_pH_coefficients <- process_coefficients(high_pH_fit_nlsLM, "Ambient pH Treatment")

low_pH_boot_resid <- process_bootstrap(low_pH_boot_residual, "Low pH Treatment")
high_pH_boot_resid <- process_bootstrap(high_pH_boot_residual, "Ambient pH Treatment")

# Correctly bind and join datasets
pH_coefficients <- bind_rows(low_pH_coefficients, high_pH_coefficients) %>% 
  dplyr::select(term, statistic, p.value, pH_condition)
boot_resid <- bind_rows(low_pH_boot_resid, high_pH_boot_resid) %>% 
  dplyr::select(term, estimate=statistic, boot.std.error, bias, pH_condition)

# Perform join using only term and pH_condition
summary_coefficients <- full_join(pH_coefficients, boot_resid, by = c("term", "pH_condition")) %>%
  format_p_values() %>% 
  group_by(pH_condition)

summary_coefficients <- summary_coefficients %>% 
mutate(
    estimate = signif(estimate, digits = 2),
    statistic = signif(statistic, digits = 2),
    bias = signif(bias, digits = 2),
    bootstrapped_std_error = signif(boot.std.error, digits = 2)
  ) %>%
  dplyr::select(term, pH_condition, estimate, bootstrapped_std_error, p.value, statistic, bias)

  
# Create the summary table
summary_table <- summary_coefficients %>% 
  gt(rowname_col = "term", groupname_col = "pH_condition") %>%
  tab_header(
    title = md("**Comparative Summary of Bootstrapped Coefficient Estimates For <br>The Sharpe-Schoolfield Model (High-Activation Energy)**")
  ) %>%
  cols_label(
    term = "Parameter",
    estimate = "Estimate",
    bootstrapped_std_error = "Std. Error",
    statistic = "Statistic",
    p.value = "P-Value",
    bias = "Bias"
  ) %>%
  text_transform(
    locations = cells_stub(
    ),
    fn = function(x) {
      sub <- str_extract(x, "(?<=_)[A-Za-z]+$")  # Extract the substring after underscore
      text <- str_extract(x, "^[A-Za-z]+")  # Extract the substring before underscore
      glue::glue("{text}<sub>{sub}</sub>")
    }
  ) %>% 
  gt_theme 

# Print the table
print(summary_table)

# Save the table as an image
gtsave(summary_table, file = here::here("Figures", "sharpe-schoolfield-summary_table.png"))

```




# Calculating Parameters and Confidence Intervals for the Sharpe-Schoolfield Model

```{r}
library(MASS)

# Calculating Parameters for fitted low pH model 
param_low_pH <- broom::tidy(low_pH_fit_nlsLM) %>%
  dplyr::select(param = term, estimate) 

# CIs from residual  resampling
ci_low_pH_residual <- confint(low_pH_boot_residual, method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  tibble::rownames_to_column(., var = 'param') %>%
  mutate(method = 'residual bootstrap')

# CIs from residual resampling
ci_param_low_pH <- bind_rows(ci_low_pH_residual) %>% 
  left_join(param_low_pH) %>% 
  mutate(pH_Treatment = "Low")

# Calculating Parameters for fitted high pH model
param_high_pH <- broom::tidy(high_pH_fit_nlsLM) %>%
  dplyr::select(param = term, estimate)

# CIs from residual resampling
ci_high_pH_residual <- confint(high_pH_boot_residual, method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  tibble::rownames_to_column(., var = 'param') %>%
  mutate(method = 'residual bootstrap')

# CIs from residual resampling high pH
ci_param_high_pH <- bind_rows(ci_high_pH_residual) %>% 
  left_join(param_high_pH) %>% 
  mutate(pH_Treatment = "Ambient")

# Combine the confidence intervals for low and high pH
ci_param <- bind_rows(ci_param_low_pH, ci_param_high_pH)

ggplot(ci_param, aes(param, estimate, color = pH_Treatment, group = pH_Treatment)) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_linerange(aes(ymin = conf_lower, ymax = conf_upper), position = position_dodge(width = 0.5)) +
  geom_hline(aes(yintercept = conf_lower, color = pH_Treatment), linetype = 2) +
  geom_hline(aes(yintercept = conf_upper, color = pH_Treatment), linetype = 2) +
  common_theme +
  theme_minimal() +
  facet_wrap(~ param, scales = 'free') +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange")) +
  scale_x_discrete('') +
  labs(title = 'Calculation of confidence intervals for TPC parameters')
```


```{r, warning =FALSE, messsage=FALSE}
# Calculate parameters for high pH fit
high_pH_fit_extra_params <- calc_params(high_pH_fit_nlsLM) %>%
  pivot_longer(everything(), names_to = 'param', values_to = 'estimate') %>%
  mutate(pH_Treatment = "Ambient") 

high_pH_ci_extra_params <- Boot(high_pH_fit_nlsLM, f = function(x){unlist(calc_params(x))}, 
  labels = names(calc_params(high_pH_fit_nlsLM)), R = 1000, method = 'residual') %>%
  confint(.,  method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  tibble::rownames_to_column(., var = 'param')  %>%
  mutate(method = 'residual bootstrap',
       pH_Treatment = "Ambient")

high_pH_ci_extra_params <- left_join(high_pH_ci_extra_params, high_pH_fit_extra_params)
  
# Calculate parameters for low pH fit
low_pH_fit_extra_params <- calc_params(low_pH_fit_nlsLM) %>%
  pivot_longer(everything(), names_to = 'param', values_to = 'estimate') %>%
  mutate(pH_Treatment = "Low")

low_pH_ci_extra_params <- Boot(low_pH_fit_nlsLM, f = function(x){unlist(calc_params(x))},
  labels = names(calc_params(low_pH_fit_nlsLM)), R = 1000, method = 'residual') %>%
  confint(.,  method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  tibble::rownames_to_column(., var = 'param')  %>%
  mutate(method = 'residual bootstrap',
       pH_Treatment = "Low")

low_pH_ci_extra_params <- left_join(low_pH_ci_extra_params, low_pH_fit_extra_params)

# Combine the confidence intervals for low and high pH
ci_extra_param <- bind_rows(low_pH_ci_extra_params, high_pH_ci_extra_params)

# Merge and filter
ci_parameters <- full_join(ci_param, ci_extra_param) %>% 
  filter(param %in% c("e", "eh", "breadth", "rmax", "topt", "ctmax"))

# Define scientific notations
sci_notations <- list(
  e = expression(Activation~Energy~(paste(E))),
  eh = expression(Deactivation~Energy~(paste(E[h]))),
  breadth = expression(Thermal~Breadth~(paste(T[Br]))),
  rmax = expression(Maximum~Rate~(paste(R[max]))),
  topt = expression(Thermal~Optimum~(paste(T[opt]))),
  ctmax =  expression(Thermal~Maximum~(paste(CT[max])))
)

# Apply labels and notations to ci_parameters
ci_parameters$param_sci <- sci_notations[ci_parameters$param]

# Convert expressions to strings suitable for ggplot2 without the "expression" wrapper
ci_parameters$param_sci <- sapply(ci_parameters$param_sci, function(item) {
  if (is.expression(item)) {
    # Deparse the inner expression to avoid "expression()" wrapper
    return(deparse(item[[1]]))
  } else {
    # Already a plain string; return as is
    return(item)
  }
})

# Ordering based on scientific notations
ordered_sci_notations <- names(sci_notations)
ci_parameters <- ci_parameters[order(match(ci_parameters$param, ordered_sci_notations)),]

# Reset row numbers
ci_parameters <- ci_parameters %>% 
  mutate(row_number = row_number())

# Step 1: Data Preprocessing
# Calculate the min and max confidence interval values for each param_sci to limit the figure upwards and downwards
ci_parameters %>%
  group_by(param_sci) %>%
  summarise(
    range_ci = max(conf_upper, na.rm = TRUE) - min(conf_lower, na.rm = TRUE),  # Determine the range of CI for each parameter
    min_conf_lower = floor(min(conf_lower, na.rm = TRUE)) - (range_ci * 0.05),  # Expand lower limit based on the CI range
    max_conf_upper = ceiling(max(conf_upper, na.rm = TRUE)) + (range_ci * 0.17)  # Expand upper limit based on the CI range
  ) -> conf_limits
# Join the limits back to the original data for plotting
ci_parameters <- left_join(ci_parameters, conf_limits, by = "param_sci") 

significant <- subset(ci_parameters, param == "rmax") %>% dplyr::select(param, param_sci, pH_Treatment, conf_upper) %>% mutate(conf_upper=conf_upper+1.5) %>%  filter(pH_Treatment == "Low")


ci_params <- ggplot(ci_parameters, aes(x = pH_Treatment, y = estimate, color = pH_Treatment, group = param_sci)) +
  geom_hline(data = conf_limits, aes(yintercept = min_conf_lower, group = param_sci), alpha = 0) +
  geom_hline(data = conf_limits, aes(yintercept = max_conf_upper, group = param_sci), alpha = 0) +
  geom_errorbar(aes(ymin = conf_lower, ymax = conf_upper), width = 0.2, size = 0.5) +
  geom_point(size = 1.8, stroke = 1) +
  geom_text(data = significant,
            aes(label = "*", hjust = 5, y = conf_upper), 
            position = position_dodge(width = -0.5),  # Adjusted position
            color = "black", size = 5) +
  facet_wrap(~factor(param_sci, levels = unique(ci_parameters$param_sci)), scales = 'free_y', labeller = label_parsed, 
             strip.position = "top", nrow = 3, ncol = 3) +
  labs(
    y = expression("Parameter Estimate (± 95% CI Range)"),
    x = NULL,  # Removing x-axis label
    legend.title = expression("pH Treatment")
  ) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"),  name="pH Treatment") +
  common_theme +
  theme(
    strip.text.x = element_text(size = 12.5),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    axis.title.y= element_text(size=16),
    legend.position = "none",
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray90", size = 0.25),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    panel.background = element_rect(fill = "white", color = "white")  # Adjust if needed
  ) +
  scale_y_continuous(breaks = scales::pretty_breaks(min.n = 4), oob = scales::oob_squish)

print(ci_params)
ggsave(here::here("Figures", "TPC_parameters.png"), ci_params, width = 8, height = 6, units = "in", dpi=1200)

```
# Thermal optimum analysis for temeprature distributions 

```{r}
# extracting Topt 
topt <- ci_parameters %>% filter(param == "topt") %>% summarise(topt=mean(estimate, na.rm = TRUE))
# Define 'topt' as a single numeric value, not as a column, for ease of use in ggplot
topt_value <- topt$topt

# Read the CSV file
newport_temp <- read_csv(here("Data", "Site_Data", "NewportBeach_TEMP_1924-2023.csv"), show_col_types = FALSE)

# Data Cleaning and Transformation
# Filter data based on TEMP_FLAG and SURF_TEMP_C values
filtered_temp_data <- newport_temp %>%
  filter(is.na(TEMP_FLAG) | TEMP_FLAG %in% c(0, 5, 6)) %>%
  filter(between(SURF_TEMP_C, 5, 35)) %>%
  mutate(Date = make_date(YEAR, MONTH, DAY)) %>%
  filter(between(Date, as.Date("2022-01-01"), as.Date("2023-01-01"))) %>% 
  dplyr::select(Date, Temperature = SURF_TEMP_C)

# Calculate Daily Mean Temperature
daily_temp_stats <- filtered_temp_data %>%
  group_by(Date) %>% 
  summarise(Mean_Temp = mean(Temperature, na.rm = TRUE)) %>% 
  mutate(topt = as.numeric(topt_value)) %>% 
  na.omit()

# Extend daily_temp_stats to include future scenarios within the same dataset
extended_temp_stats <- daily_temp_stats %>%
  mutate(Scenario = "Sea Surface Temperature Distribution (2022)",
         Adjusted_Temp = Mean_Temp, 
         color=ifelse(Adjusted_Temp > topt, "orange2","gold1")) %>%
  bind_rows(
    daily_temp_stats %>% 
      mutate(Scenario = "Sea Surface Temperature Distribution (+2°C)",
             Adjusted_Temp = Mean_Temp + 2,
             color=ifelse(Adjusted_Temp > topt, "orange2", "gold1")),
    daily_temp_stats %>%
      mutate(Scenario = "Sea Surface Temperature Distribution (+4°C)",
             Adjusted_Temp = Mean_Temp + 4,
             color=ifelse(Adjusted_Temp > topt, "orange2", "gold1"))
  ) %>%
  mutate(Exceeds_Topt = Adjusted_Temp > topt_value, 
         Topt=ifelse(Adjusted_Temp > topt_value, "Exceeds T_opt", "Below T_opt")) %>% 
  na.omit(Adjusted_Temp)

# To calculate the percentage exceeding 'topt' for each 'Scenario'
exceeds_topt_percentages <- extended_temp_stats %>%
  group_by(Scenario) %>%
  summarise(
    Percentage = mean(Exceeds_Topt) * 100 # This gives you the percentage
  )

# View the percentages
print(exceeds_topt_percentages)



extended_temp_stats <- left_join(extended_temp_stats, exceeds_topt_percentages, by = "Scenario")

# Adjust the Scenario ordering
extended_temp_stats$Scenario <- factor(extended_temp_stats$Scenario, 
                                       levels = c("Sea Surface Temperature Distribution (2022)",
                                                  "Sea Surface Temperature Distribution (+2°C)",
                                                  "Sea Surface Temperature Distribution (+4°C)"))

common_theme_2 <- common_theme + theme(legend.position = "bottom")

topt_distribution <- ggplot(extended_temp_stats, aes(x = Adjusted_Temp, fill = as.factor(Topt))) +
  geom_histogram(color = "black", binwidth = 0.2, linewidth = 0.1) +
  geom_vline(xintercept = topt_value, color = "darkred", linetype = "dashed", size = 0.8) +  # Use dynamic topt_value
  facet_wrap(~Scenario, scales = "free_y", ncol = 1) +
  labs(
    x = "Sea Surface Temperature (°C)",
    y = "Frequency",
    fill = NULL  # Set to NULL since we handle legend title below
  ) +
  scale_fill_manual(
    values = c("Exceeds T_opt" = "red3", "Below T_opt" = "gold1"),
    labels = c(expression(paste("Below T"[opt])), expression(paste("Exceeds T"[opt])))  # TeX-style subscripts
  ) +
  scale_x_continuous(expand = c(0, 0), breaks = seq(10, 30, 2)) +
  scale_y_continuous(expand = c(0, 0), breaks = seq(0, 20, 5), limits = c(0, 20)) + 
  common_theme_2 +
  theme(
    text = element_text(family = "serif"),
    legend.margin = margin(t = 0, r = 15, b = 0, l = 15, unit = "pt")  # Adjusted legend margins
  ) +
  geom_text(aes(label = paste0(round(Percentage, 1), "%"), y = Inf, x = 29), vjust = 1.75, hjust = 1.5, size = 4, color = "red3", family="serif") +
  common_theme +
  theme(
    strip.text.x = element_text(size = 16),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    axis.title.y= element_text(size=16),
    axis.title.x= element_text(size=16),
    legend.position = "bottom",
    legend.text = element_text(size = 12.5),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray90", size = 0.25),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.background = element_rect(fill = "white", color = "white")  # Adjust if needed
  ) 

# Print the plot to view
print(topt_distribution)

# Save the plot
ggsave(here::here("Figures", "Temperature_Distribution.png"), plot = topt_distribution, width = 8, height = 6, units = "in")

```



```{r}

# Estimating Q10 temperature coefficient (thermal sensitivty) for respirometry data 
 
# Estimating Q10 values for low and high pH data 
respo.rates.Q10 = respirometry::Q10(R_vec=respo.rates.tpc$rate, T_vec=respo.rates.tpc$temp)

respo.rates.low = respo.rates.tpc %>% filter(pH_Treatment == "Low")
respo.rates.low.pH.Q10 = respirometry::Q10(R_vec=respo.rates.low$rate, T_vec=respo.rates.low$temp)

respo.rates.high = respo.rates.tpc %>% filter(pH_Treatment == "Ambient")
respo.rates.high.pH.Q10 = respirometry::Q10(R_vec=respo.rates.high$rate, T_vec=respo.rates.high$temp)

print(paste("Tegula funebralis (Q10):", respo.rates.Q10))
print(paste("Tegula funebralis (Low pH Q10):", respo.rates.low.pH.Q10))
print(paste("Tegula funebralis (High pH Q10):", respo.rates.high.pH.Q10))

# Create a data frame to hold Q10 values
q10_values <- data.frame(
  Treatment = c("Tegula funebralis (Overall)", "Tegula funebralis (Low pH)", "Tegula funebralis (High pH)"),
  Q10 = c(respo.rates.Q10, respo.rates.low.pH.Q10, respo.rates.high.pH.Q10)
)

# Save the data frame to a CSV file in the Figures directory
write.csv(q10_values, file = here("Figures", "Tegula_funebralis_Q10_values.csv"), row.names = FALSE)
```




# Fitting the Sharpe-Schoolfield Model to Weighted Average Respiration Rates Across Temperature

```{r}
#Averaging Rates by temperature and pH treatment 
avg.respo.rates.tpc <- respo.rates.dataset %>% 
  mutate(rate=umolO2.gram.hr, temp=Temp.C) %>%
  group_by(Temp_Treatment, pH_Treatment) %>% 
  summarise(., sd = sd(rate),
            rate = mean(rate),
            temp = mean(temp),
            .groups = 'drop') %>% ungroup() %>% 
  dplyr::select(pH_Treatment, temp, rate, sd)

# keeping just a single curve
low_pH_mean <- filter(avg.respo.rates.tpc, pH_Treatment == 'Low') %>% 
  dplyr::select(-pH_Treatment)

high_pH_mean <- filter(avg.respo.rates.tpc, pH_Treatment == 'Ambient') %>% 
  dplyr::select(-pH_Treatment)

# Fit the Sharpe-Schoolfield model for low pH
sharpeschoolhigh_fit_low_pH_mean <- nest(low_pH_mean, data = c(temp, rate, sd)) %>%
  mutate(sharpeschoolhigh = map(data, ~nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 20),
                        data = .x,
                        iter = c(4,4,4,4),
                        start_lower = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') - 10,
                        start_upper = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') + 10,
                        lower = get_lower_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        supp_errors = 'Y',
                        convergence_count = FALSE,
                        #including weights for each replicate here
                        modelweights = 1/sd)))

# get predictions using augment for low pH
low_pH_mean_newdata <- tibble(temp = seq(min(low_pH_mean$temp), max(low_pH_mean$temp), length.out = 100))
sharpeschoolhigh_fit_low_pH_mean_preds <- sharpeschoolhigh_fit_low_pH_mean %>%
  mutate(., preds = map(sharpeschoolhigh, augment, newdata = low_pH_mean_newdata)) %>%
  mutate(pH_Treatment="Low") %>% 
  dplyr::select(-sharpeschoolhigh) %>%
  unnest(preds)

# Fit the Sharpe-Schoolfield model for high pH
sharpeschoolhigh_fit_high_pH_mean <- nest(high_pH_mean, data = c(temp, rate, sd)) %>%
  mutate(sharpeschoolhigh = map(data, ~nls_multstart(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 20),
                        data = .x,
                        iter = c(4,4,4,4),
                        start_lower = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') - 10,
                        start_upper = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') + 10,
                        lower = get_lower_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        supp_errors = 'Y',
                        convergence_count = FALSE,
                        #including weights for each replicate here
                        modelweights = 1/sd)))

# get predictions using augment for high pH 
high_pH_mean_newdata <- tibble(temp = seq(min(high_pH_mean$temp), max(high_pH_mean$temp), length.out = 100))
sharpeschoolhigh_fit_high_pH_mean_preds <- sharpeschoolhigh_fit_high_pH_mean %>%
  mutate(., preds = map(sharpeschoolhigh, augment, newdata = high_pH_mean_newdata)) %>%
  mutate(pH_Treatment="Ambient") %>% 
  dplyr::select(-sharpeschoolhigh) %>%
  unnest(preds)

high_pH_mean <- high_pH_mean %>% mutate(pH_Treatment = "Ambient")
low_pH_mean <- low_pH_mean %>% mutate(pH_Treatment = "Low")

# Joining and low and high pH prediction for plotting 
avg_TPC_rates <- full_join(high_pH_mean, low_pH_mean)
avg_TPC_preds <- full_join(sharpeschoolhigh_fit_high_pH_mean_preds, sharpeschoolhigh_fit_low_pH_mean_preds)

# plotting TPC for Sharpe-Schoolfield (high activation) model 
ggplot() +
  geom_line(aes(temp, .fitted, group=pH_Treatment, color=pH_Treatment), avg_TPC_preds) +
  geom_linerange(aes(x = temp, ymin = rate - sd, ymax = rate + sd, group=pH_Treatment), avg_TPC_rates) +
  geom_point(aes(temp, rate, group=pH_Treatment, fill=pH_Treatment), avg_TPC_rates, size = 2, shape = 21) +
  facet_wrap(~pH_Treatment) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  scale_fill_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  theme_bw(base_size = 12) +
  common_theme +
  labs(x = xlab,
       y = ylab) + 
  scale_y_continuous(breaks = seq(0, 125, 25), limits=c(0,110)) +
  scale_x_continuous(breaks = seq(12, 26, 2), limits=c(12,26.5), position = "bottom") +
  geom_hline(yintercept = 0, linetype = 2)

```

# Bootstrapping the Sharpe-Schoolfield Model to Weighted Average Respiration Rates Across Temperature

```{r}

# Fit the Sharpe-Schoolfield model for low pH using nmls model prior to bootstrap
low_pH_mean_fit_nlsLM <- minpack.lm::nlsLM(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = low_pH_mean,
                        start = coef(sharpeschoolhigh_fit_low_pH_mean$sharpeschoolhigh[[1]]),
                        lower = get_lower_lims(low_pH_mean$temp, low_pH_mean$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(low_pH_mean$temp, low_pH_mean$rate, model_name = 'sharpeschoolhigh_1981'),
                        weights = 1/sd)

# perform bootstrapping (case versus residual) for low pH
low_pH_mean_case_bootstrap <- Boot(low_pH_mean_fit_nlsLM, method = 'case', R=999)
low_pH_mean_residual_bootstrap <- Boot(low_pH_mean_fit_nlsLM, method = 'residual', R=999)  # using residual bootstrapping due to lower standard error 

# predict over new data
low_pH_mean_residual_bootstrap_preds <- low_pH_mean_residual_bootstrap$t %>%
  as.data.frame() %>%
  drop_na() %>%
  mutate(iter = 1:n()) %>%
  group_by_all() %>%
  do(data.frame(temp = seq(min(low_pH_mean$temp), max(low_pH_mean$temp), length.out = 100))) %>%
  ungroup() %>%
  mutate(pred = sharpeschoolhigh_1981(temp, r_tref, e, eh, th, tref=15)) %>% 
  mutate(pH_Treatment = "Low")

# calculate bootstrapped confidence intervals
low_pH_mean_residual_bootstrap_CI_preds <- group_by(low_pH_mean_residual_bootstrap_preds, temp) %>%
  summarise(conf_lower = quantile(pred, 0.025),
            conf_upper = quantile(pred, 0.975),
            .groups = 'drop') %>% 
  mutate(pH_Treatment = "Low")

# Fit the Sharpe-Schoolfield model for high pH using nmls model prior to bootstrap
high_pH_mean_fit_nlsLM <- minpack.lm::nlsLM(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = high_pH_mean,
                        start = coef(sharpeschoolhigh_fit_high_pH_mean$sharpeschoolhigh[[1]]),
                        lower = get_lower_lims(high_pH_mean$temp, high_pH_mean$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(high_pH_mean$temp, high_pH_mean$rate, model_name = 'sharpeschoolhigh_1981'),
                        weights = 1/sd)

# perform bootstrapping (case versus residual) for high pH
high_pH_mean_case_bootstrap <- Boot(high_pH_mean_fit_nlsLM, method = 'case', R=999)
high_pH_mean_residual_bootstrap <- Boot(high_pH_mean_fit_nlsLM, method = 'residual', R=999)

# predict over new data
high_pH_mean_residual_bootstrap_preds <- high_pH_mean_residual_bootstrap$t %>%
  as.data.frame() %>%
  drop_na() %>%
  mutate(iter = 1:n()) %>%
  group_by_all() %>%
  do(data.frame(temp = seq(min(high_pH_mean$temp), max(high_pH_mean$temp), length.out = 100))) %>%
  ungroup() %>%
  mutate(pred = sharpeschoolhigh_1981(temp, r_tref, e, eh, th, tref=15)) %>% 
  mutate(pH_Treatment = "Ambient")

# calculate bootstrapped confidence intervals
high_pH_mean_residual_bootstrap_CI_preds <- group_by(high_pH_mean_residual_bootstrap_preds, temp) %>%
  summarise(conf_lower = quantile(pred, 0.025),
            conf_upper = quantile(pred, 0.975),
            .groups = 'drop') %>% 
  mutate(pH_Treatment = "Ambient")

# joining residual bootstrap preds and confidence intervals (95%)
residual_bootstrap_preds <- full_join(high_pH_mean_residual_bootstrap_preds, low_pH_mean_residual_bootstrap_preds)
residual_bootstrap_CI_preds <- full_join(high_pH_mean_residual_bootstrap_CI_preds, low_pH_mean_residual_bootstrap_CI_preds)

# plotting TPC for Sharpe-Schoolfield (high activation) model 
avg_TPC_CI_plot <- ggplot() +
  geom_line(aes(temp, .fitted, group=pH_Treatment, color=pH_Treatment), avg_TPC_preds) +
  geom_ribbon(aes(temp, ymin = conf_lower, ymax = conf_upper, fill=pH_Treatment), residual_bootstrap_CI_preds, alpha = 0.2) +
  geom_linerange(aes(x = temp, ymin = rate - sd, ymax = rate + sd, group=pH_Treatment), avg_TPC_rates) +
  geom_point(aes(temp, rate, group=pH_Treatment, fill=pH_Treatment), avg_TPC_rates, size = 2, shape = 21) +
  facet_wrap(~pH_Treatment) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  scale_fill_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  theme_bw(base_size = 12) +
  common_theme +
  labs(x = xlab,
       y = ylab) + 
  scale_y_continuous(breaks = seq(0, 125, 25), limits=c(0,100)) +
  scale_x_continuous(breaks = seq(12, 26, 2), limits=c(12,26.5), position = "bottom") +
  geom_hline(yintercept = 0, linetype = 2)

# plotting TPC for Sharpe-Schoolfield (high activation) model 
avg_TPC_predictions_plot <-ggplot() +
  geom_line(aes(temp, .fitted, group=pH_Treatment, color=pH_Treatment), avg_TPC_preds) +
  geom_line(aes(temp, pred, group = iter, col=pH_Treatment), residual_bootstrap_preds, alpha = 0.008) +
  geom_linerange(aes(x = temp, ymin = rate - sd, ymax = rate + sd, group=pH_Treatment), avg_TPC_rates) +
  geom_point(aes(temp, rate, group=pH_Treatment, fill=pH_Treatment), avg_TPC_rates, size = 2, shape = 21) +
  facet_wrap(~pH_Treatment) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  scale_fill_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  theme_bw(base_size = 12) +
  common_theme +
  labs(x = xlab,
       y = ylab) + 
  scale_y_continuous(breaks = seq(0, 125, 25), limits=c(0,100)) +
  scale_x_continuous(breaks = seq(12, 26, 2), limits=c(12,26.5), position = "bottom") +
  geom_hline(yintercept = 0, linetype = 2)

combined_avg_plots <- ggplot() +
  geom_line(aes(temp, .fitted, group=pH_Treatment, color=pH_Treatment), avg_TPC_preds) +
  geom_ribbon(aes(temp, ymin = conf_lower, ymax = conf_upper, fill=pH_Treatment), residual_bootstrap_CI_preds, alpha = 0.2) +
  geom_line(aes(temp, pred, group = iter, col=pH_Treatment), residual_bootstrap_preds, alpha = 0.008) +
  geom_linerange(aes(x = temp, ymin = rate - sd, ymax = rate + sd, group=pH_Treatment), avg_TPC_rates) +
  geom_point(aes(temp, rate, group=pH_Treatment, fill=pH_Treatment), avg_TPC_rates, size = 2, shape = 21) +
  facet_wrap(~pH_Treatment) +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  scale_fill_manual(values = c("Low" = "cyan3", "Ambient" = "orange"), guide = "none") +
  theme_bw(base_size = 12) +
  common_theme +
  labs(x = xlab,
       y = ylab) + 
  scale_y_continuous(breaks = seq(0, 125, 25), limits=c(0,100)) +
  scale_x_continuous(breaks = seq(12, 26, 2), limits=c(12,26.5), position = "bottom") +
  geom_hline(yintercept = 0, linetype = 2)

print(avg_TPC_CI_plot)
print(avg_TPC_predictions_plot)
print(combined_avg_plots)

# Save the plots as a PNG file
ggsave(here::here("Figures", "TPC_CI_combined_weighted_avg_plot.png"), combined_avg_plots, width = 10, height = 10, units = "in")

```



```{r}
library(MASS)
# get parameters of fitted model
low_pH_params <- broom::tidy(low_pH_mean_fit_nlsLM)  %>%
  dplyr::select(param = term, estimate) 
  
# CIs from residual resampling
ci_low_pH_residual <- low_pH_mean_residual_bootstrap %>%
  confint(., method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  rownames_to_column(., var = 'param') %>%
  mutate(method = 'residual bootstrap')

low_pH_params <-left_join(low_pH_params, ci_low_pH_residual) %>%
  mutate(pH_Treatment = "Low")

# residul Bootstrapping Extracted Parameters
low_pH_extra_params <- calc_params(low_pH_mean_fit_nlsLM) %>%
  pivot_longer(everything(), names_to =  'param', values_to = 'estimate') %>% 
  filter(param != 'th', param != 'tref', param != 'e', param != "eh", param != "q10") %>%
  na.omit()

# residual Bootstrapping Extracted Parameters
ci_low_extra_params_residual <- Boot(low_pH_mean_fit_nlsLM , f = function(x){unlist(calc_params(x))},
  labels = names(calc_params(low_pH_mean_fit_nlsLM )), R = 999, method = 'residual') %>%
  confint(., method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  rownames_to_column(., var = 'param') %>%
  mutate(method = 'residual bootstrap', 
         pH_Treatment = 'Low')

low_pH_extra_params <-left_join(low_pH_extra_params, ci_low_extra_params_residual) %>%
  mutate(pH_Treatment = "Low")

full_low_pH_params <- bind_rows(low_pH_params, low_pH_extra_params)

high_pH_params <- broom::tidy(high_pH_mean_fit_nlsLM)  %>%
  dplyr::select(param = term, estimate)

# CIs from residual resampling
ci_high_pH_residual <- high_pH_mean_residual_bootstrap %>%
  confint(., method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  rownames_to_column(., var = 'param') %>%
  mutate(method = 'residual bootstrap')

high_pH_params <-left_join(high_pH_params, ci_high_pH_residual) %>%
  
  mutate(pH_Treatment = "Ambient")

# Case Bootstrapping Extracted Parameters
high_pH_extra_params <- calc_params(high_pH_mean_fit_nlsLM) %>%
  pivot_longer(everything(), names_to =  'param', values_to = 'estimate') %>% 
  filter(param != 'th', param != 'tref', param != 'e', param != "eh", param != "q10") %>%
  na.omit()

# Case Bootstrapping Extracted Parameters
ci_high_extra_params_residual <- Boot(high_pH_mean_fit_nlsLM , f = function(x){unlist(calc_params(x))},
  labels = names(calc_params(high_pH_mean_fit_nlsLM)), R = 999, method = 'residual') %>%
  confint(., method = 'bca', level = 0.95) %>%
  as.data.frame() %>%
  rename(conf_lower = 1, conf_upper = 2) %>%
  rownames_to_column(., var = 'param') %>%
  mutate(method = 'residual bootstrap', 
         pH_Treatment = 'Ambient')

high_pH_extra_params <-left_join(high_pH_extra_params, ci_high_extra_params_residual) %>%
  
  mutate(pH_Treatment = "Ambient")

full_high_pH_params <- bind_rows(high_pH_params, high_pH_extra_params)

# Combine the confidence intervals for low and high pH

ci_param <- bind_rows(full_low_pH_params, full_high_pH_params)

ggplot(ci_param, aes(param, estimate, color = pH_Treatment, group = pH_Treatment)) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_linerange(aes(ymin = conf_lower, ymax = conf_upper), position = position_dodge(width = 0.5)) +
  geom_hline(aes(yintercept = conf_lower, color = pH_Treatment), linetype = 2) +
  geom_hline(aes(yintercept = conf_upper, color = pH_Treatment), linetype = 2) +
  common_theme +
  theme_minimal() +
  facet_wrap(~param, scales = 'free') +
  scale_color_manual(values = c("Low" = "cyan3", "Ambient" = "orange")) +
  scale_x_discrete('') +
  labs(title = 'Calculation of confidence intervals for model parameters')

```

# Calculating Metablic Information from Respiration Rates
```{r, Calulcating Metabolic Data}


# Estimating Q10 temperature coefficient (thermal sensitivty) for respirometry data 
 
# Estimating Q10 values for low and high pH data 
respo.rates.Q10 = respirometry::Q10(R_vec=respo.rates.tpc$rate, T_vec=respo.rates.tpc$temp)

respo.rates.low = respo.rates.tpc %>% filter(pH_Treatment == "Low")
respo.rates.low.pH.Q10 = respirometry::Q10(R_vec=respo.rates.low$rate, T_vec=respo.rates.low$temp)

respo.rates.high = respo.rates.tpc %>% filter(pH_Treatment == "Ambient")
respo.rates.high.pH.Q10 = respirometry::Q10(R_vec=respo.rates.high$rate, T_vec=respo.rates.high$temp)

print(paste("Tegula funebralis (Q10):", respo.rates.Q10))
print(paste("Tegula funebralis (Low pH Q10):", respo.rates.low.pH.Q10))
print(paste("Tegula funebralis (High pH Q10):", respo.rates.high.pH.Q10))

# Calculating mean respiration rate at each temperature
mean_rates_low <- aggregate(rate ~ temp, data = respo.rates.low, FUN = mean)
mean_rates_high <- aggregate(rate ~ temp, data = respo.rates.high, FUN = mean)

# Identifying temperature at which respiration rate is maximum
max_temp_low <- mean_rates_low$temp[which.max(mean_rates_low$rate)]
max_temp_high <- mean_rates_high$temp[which.max(mean_rates_high$rate)]

# Topt maximum respiration rate
print(paste("Tegula funebralis (Low pH Topt):", max_temp_low))
print(paste("Tegula funebralis (High pH Topt):", max_temp_high))

```









